<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0195-associated-items - The Rust RFC Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="0001-private-fields.html">0001-private-fields</a></li><li><a href="0002-rfc-process.html">0002-rfc-process</a></li><li><a href="0003-attribute-usage.html">0003-attribute-usage</a></li><li><a href="0008-new-intrinsics.html">0008-new-intrinsics</a></li><li><a href="0016-more-attributes.html">0016-more-attributes</a></li><li><a href="0019-opt-in-builtin-traits.html">0019-opt-in-builtin-traits</a></li><li><a href="0026-remove-priv.html">0026-remove-priv</a></li><li><a href="0034-bounded-type-parameters.html">0034-bounded-type-parameters</a></li><li><a href="0040-libstd-facade.html">0040-libstd-facade</a></li><li><a href="0042-regexps.html">0042-regexps</a></li><li><a href="0048-traits.html">0048-traits</a></li><li><a href="0049-match-arm-attributes.html">0049-match-arm-attributes</a></li><li><a href="0050-assert.html">0050-assert</a></li><li><a href="0059-remove-tilde.html">0059-remove-tilde</a></li><li><a href="0060-rename-strbuf.html">0060-rename-strbuf</a></li><li><a href="0063-module-file-system-hierarchy.html">0063-module-file-system-hierarchy</a></li><li><a href="0066-better-temporary-lifetimes.html">0066-better-temporary-lifetimes</a></li><li><a href="0068-const-unsafe-pointers.html">0068-const-unsafe-pointers</a></li><li><a href="0069-ascii-literals.html">0069-ascii-literals</a></li><li><a href="0071-const-block-expr.html">0071-const-block-expr</a></li><li><a href="0079-undefined-struct-layout.html">0079-undefined-struct-layout</a></li><li><a href="0085-pattern-macros.html">0085-pattern-macros</a></li><li><a href="0086-plugin-registrar.html">0086-plugin-registrar</a></li><li><a href="0087-trait-bounds-with-plus.html">0087-trait-bounds-with-plus</a></li><li><a href="0089-loadable-lints.html">0089-loadable-lints</a></li><li><a href="0090-lexical-syntax-simplification.html">0090-lexical-syntax-simplification</a></li><li><a href="0092-struct-grammar.html">0092-struct-grammar</a></li><li><a href="0093-remove-format-intl.html">0093-remove-format-intl</a></li><li><a href="0100-partial-cmp.html">0100-partial-cmp</a></li><li><a href="0107-pattern-guards-with-bind-by-move.html">0107-pattern-guards-with-bind-by-move</a></li><li><a href="0109-remove-crate-id.html">0109-remove-crate-id</a></li><li><a href="0111-index-traits.html">0111-index-traits</a></li><li><a href="0112-remove-cross-borrowing.html">0112-remove-cross-borrowing</a></li><li><a href="0114-closures.html">0114-closures</a></li><li><a href="0115-rm-integer-fallback.html">0115-rm-integer-fallback</a></li><li><a href="0116-no-module-shadowing.html">0116-no-module-shadowing</a></li><li><a href="0123-share-to-threadsafe.html">0123-share-to-threadsafe</a></li><li><a href="0130-box-not-special.html">0130-box-not-special</a></li><li><a href="0131-target-specification.html">0131-target-specification</a></li><li><a href="0132-ufcs.html">0132-ufcs</a></li><li><a href="0135-where.html">0135-where</a></li><li><a href="0136-no-privates-in-public.html">0136-no-privates-in-public</a></li><li><a href="0139-remove-cross-borrowing-entirely.html">0139-remove-cross-borrowing-entirely</a></li><li><a href="0141-lifetime-elision.html">0141-lifetime-elision</a></li><li><a href="0151-capture-by-value.html">0151-capture-by-value</a></li><li><a href="0155-anonymous-impl-only-in-same-module.html">0155-anonymous-impl-only-in-same-module</a></li><li><a href="0160-if-let.html">0160-if-let</a></li><li><a href="0164-feature-gate-slice-pats.html">0164-feature-gate-slice-pats</a></li><li><a href="0168-mod.html">0168-mod</a></li><li><a href="0169-use-path-as-id.html">0169-use-path-as-id</a></li><li><a href="0179-and-mut-patterns.html">0179-and-mut-patterns</a></li><li><a href="0184-tuple-accessors.html">0184-tuple-accessors</a></li><li><a href="0192-bounds-on-object-and-generic-types.html">0192-bounds-on-object-and-generic-types</a></li><li><a href="0194-cfg-syntax.html">0194-cfg-syntax</a></li><li><a href="0195-associated-items.html" class="active">0195-associated-items</a></li><li><a href="0198-slice-notation.html">0198-slice-notation</a></li><li><a href="0199-ownership-variants.html">0199-ownership-variants</a></li><li><a href="0201-error-chaining.html">0201-error-chaining</a></li><li><a href="0202-subslice-syntax-change.html">0202-subslice-syntax-change</a></li><li><a href="0212-restore-int-fallback.html">0212-restore-int-fallback</a></li><li><a href="0213-defaulted-type-params.html">0213-defaulted-type-params</a></li><li><a href="0214-while-let.html">0214-while-let</a></li><li><a href="0216-collection-views.html">0216-collection-views</a></li><li><a href="0218-empty-struct-with-braces.html">0218-empty-struct-with-braces</a></li><li><a href="0221-panic.html">0221-panic</a></li><li><a href="0230-remove-runtime.html">0230-remove-runtime</a></li><li><a href="0231-upvar-capture-inference.html">0231-upvar-capture-inference</a></li><li><a href="0234-variants-namespace.html">0234-variants-namespace</a></li><li><a href="0235-collections-conventions.html">0235-collections-conventions</a></li><li><a href="0236-error-conventions.html">0236-error-conventions</a></li><li><a href="0240-unsafe-api-location.html">0240-unsafe-api-location</a></li><li><a href="0241-deref-conversions.html">0241-deref-conversions</a></li><li><a href="0243-trait-based-exception-handling.html">0243-trait-based-exception-handling</a></li><li><a href="0246-const-vs-static.html">0246-const-vs-static</a></li><li><a href="0255-object-safety.html">0255-object-safety</a></li><li><a href="0256-remove-refcounting-gc-of-t.html">0256-remove-refcounting-gc-of-t</a></li><li><a href="0320-nonzeroing-dynamic-drop.html">0320-nonzeroing-dynamic-drop</a></li><li><a href="0326-restrict-xXX-to-ascii.html">0326-restrict-xXX-to-ascii</a></li><li><a href="0339-statically-sized-literals.html">0339-statically-sized-literals</a></li><li><a href="0341-remove-virtual-structs.html">0341-remove-virtual-structs</a></li><li><a href="0342-keywords.html">0342-keywords</a></li><li><a href="0344-conventions-galore.html">0344-conventions-galore</a></li><li><a href="0356-no-module-prefixes.html">0356-no-module-prefixes</a></li><li><a href="0369-num-reform.html">0369-num-reform</a></li><li><a href="0378-expr-macros.html">0378-expr-macros</a></li><li><a href="0379-remove-reflection.html">0379-remove-reflection</a></li><li><a href="0380-stabilize-std-fmt.html">0380-stabilize-std-fmt</a></li><li><a href="0385-module-system-cleanup.html">0385-module-system-cleanup</a></li><li><a href="0387-higher-ranked-trait-bounds.html">0387-higher-ranked-trait-bounds</a></li><li><a href="0390-enum-namespacing.html">0390-enum-namespacing</a></li><li><a href="0401-coercions.html">0401-coercions</a></li><li><a href="0403-cargo-build-command.html">0403-cargo-build-command</a></li><li><a href="0404-change-prefer-dynamic.html">0404-change-prefer-dynamic</a></li><li><a href="0418-struct-variants.html">0418-struct-variants</a></li><li><a href="0430-finalizing-naming-conventions.html">0430-finalizing-naming-conventions</a></li><li><a href="0438-precedence-of-plus.html">0438-precedence-of-plus</a></li><li><a href="0439-cmp-ops-reform.html">0439-cmp-ops-reform</a></li><li><a href="0445-extension-trait-conventions.html">0445-extension-trait-conventions</a></li><li><a href="0446-es6-unicode-escapes.html">0446-es6-unicode-escapes</a></li><li><a href="0447-no-unused-impl-parameters.html">0447-no-unused-impl-parameters</a></li><li><a href="0450-un-feature-gate-some-more-gates.html">0450-un-feature-gate-some-more-gates</a></li><li><a href="0453-macro-reform.html">0453-macro-reform</a></li><li><a href="0458-send-improvements.html">0458-send-improvements</a></li><li><a href="0459-disallow-shadowing.html">0459-disallow-shadowing</a></li><li><a href="0461-tls-overhaul.html">0461-tls-overhaul</a></li><li><a href="0463-future-proof-literal-suffixes.html">0463-future-proof-literal-suffixes</a></li><li><a href="0469-feature-gate-box-patterns.html">0469-feature-gate-box-patterns</a></li><li><a href="0474-path-reform.html">0474-path-reform</a></li><li><a href="0486-std-ascii-reform.html">0486-std-ascii-reform</a></li><li><a href="0490-dst-syntax.html">0490-dst-syntax</a></li><li><a href="0494-c_str-and-c_vec-stability.html">0494-c_str-and-c_vec-stability</a></li><li><a href="0495-array-pattern-changes.html">0495-array-pattern-changes</a></li><li><a href="0501-consistent_no_prelude_attributes.html">0501-consistent_no_prelude_attributes</a></li><li><a href="0503-prelude-stabilization.html">0503-prelude-stabilization</a></li><li><a href="0504-show-stabilization.html">0504-show-stabilization</a></li><li><a href="0505-api-comment-conventions.html">0505-api-comment-conventions</a></li><li><a href="0507-release-channels.html">0507-release-channels</a></li><li><a href="0509-collections-reform-part-2.html">0509-collections-reform-part-2</a></li><li><a href="0517-io-os-reform.html">0517-io-os-reform</a></li><li><a href="0520-new-array-repeat-syntax.html">0520-new-array-repeat-syntax</a></li><li><a href="0522-self-impl.html">0522-self-impl</a></li><li><a href="0526-fmt-text-writer.html">0526-fmt-text-writer</a></li><li><a href="0528-string-patterns.html">0528-string-patterns</a></li><li><a href="0529-conversion-traits.html">0529-conversion-traits</a></li><li><a href="0531-define-rfc-scope.html">0531-define-rfc-scope</a></li><li><a href="0532-self-in-use.html">0532-self-in-use</a></li><li><a href="0533-no-array-elem-moves.html">0533-no-array-elem-moves</a></li><li><a href="0534-deriving2derive.html">0534-deriving2derive</a></li><li><a href="0544-rename-int-uint.html">0544-rename-int-uint</a></li><li><a href="0546-Self-not-sized-by-default.html">0546-Self-not-sized-by-default</a></li><li><a href="0550-macro-future-proofing.html">0550-macro-future-proofing</a></li><li><a href="0556-raw-lifetime.html">0556-raw-lifetime</a></li><li><a href="0558-require-parentheses-for-chained-comparisons.html">0558-require-parentheses-for-chained-comparisons</a></li><li><a href="0560-integer-overflow.html">0560-integer-overflow</a></li><li><a href="0563-remove-ndebug.html">0563-remove-ndebug</a></li><li><a href="0565-show-string-guidelines.html">0565-show-string-guidelines</a></li><li><a href="0572-rustc-attribute.html">0572-rustc-attribute</a></li><li><a href="0574-drain-range.html">0574-drain-range</a></li><li><a href="0580-rename-collections.html">0580-rename-collections</a></li><li><a href="0587-fn-return-should-be-an-associated-type.html">0587-fn-return-should-be-an-associated-type</a></li><li><a href="0592-c-str-deref.html">0592-c-str-deref</a></li><li><a href="0593-forbid-Self-definitions.html">0593-forbid-Self-definitions</a></li><li><a href="0599-default-object-bound.html">0599-default-object-bound</a></li><li><a href="0601-replace-be-with-become.html">0601-replace-be-with-become</a></li><li><a href="0639-discriminant-intrinsic.html">0639-discriminant-intrinsic</a></li><li><a href="0640-debug-improvements.html">0640-debug-improvements</a></li><li><a href="0702-rangefull-expression.html">0702-rangefull-expression</a></li><li><a href="0735-allow-inherent-impls-anywhere.html">0735-allow-inherent-impls-anywhere</a></li><li><a href="0736-privacy-respecting-fru.html">0736-privacy-respecting-fru</a></li><li><a href="0738-variance.html">0738-variance</a></li><li><a href="0769-sound-generic-drop.html">0769-sound-generic-drop</a></li><li><a href="0771-std-iter-once.html">0771-std-iter-once</a></li><li><a href="0803-type-ascription.html">0803-type-ascription</a></li><li><a href="0809-box-and-in-for-stdlib.html">0809-box-and-in-for-stdlib</a></li><li><a href="0823-hash-simplification.html">0823-hash-simplification</a></li><li><a href="0832-from-elem-with-love.html">0832-from-elem-with-love</a></li><li><a href="0839-embrace-extend-extinguish.html">0839-embrace-extend-extinguish</a></li><li><a href="0840-no-panic-in-c-string.html">0840-no-panic-in-c-string</a></li><li><a href="0873-type-macros.html">0873-type-macros</a></li><li><a href="0879-small-base-lexing.html">0879-small-base-lexing</a></li><li><a href="0888-compiler-fence-intrinsics.html">0888-compiler-fence-intrinsics</a></li><li><a href="0909-move-thread-local-to-std-thread.html">0909-move-thread-local-to-std-thread</a></li><li><a href="0911-const-fn.html">0911-const-fn</a></li><li><a href="0921-entry_v3.html">0921-entry_v3</a></li><li><a href="0940-hyphens-considered-harmful.html">0940-hyphens-considered-harmful</a></li><li><a href="0953-op-assign.html">0953-op-assign</a></li><li><a href="0968-closure-return-type-syntax.html">0968-closure-return-type-syntax</a></li><li><a href="0979-align-splitn-with-other-languages.html">0979-align-splitn-with-other-languages</a></li><li><a href="0980-read-exact.html">0980-read-exact</a></li><li><a href="0982-dst-coercion.html">0982-dst-coercion</a></li><li><a href="1011-process.exit.html">1011-process.exit</a></li><li><a href="1014-stdout-existential-crisis.html">1014-stdout-existential-crisis</a></li><li><a href="1023-rebalancing-coherence.html">1023-rebalancing-coherence</a></li><li><a href="1030-prelude-additions.html">1030-prelude-additions</a></li><li><a href="1040-duration-reform.html">1040-duration-reform</a></li><li><a href="1044-io-fs-2.1.html">1044-io-fs-2.1</a></li><li><a href="1047-socket-timeouts.html">1047-socket-timeouts</a></li><li><a href="1048-rename-soft-link-to-symlink.html">1048-rename-soft-link-to-symlink</a></li><li><a href="1054-str-words.html">1054-str-words</a></li><li><a href="1057-io-error-sync.html">1057-io-error-sync</a></li><li><a href="1058-slice-tail-redesign.html">1058-slice-tail-redesign</a></li><li><a href="1066-safe-mem-forget.html">1066-safe-mem-forget</a></li><li><a href="1068-rust-governance.html">1068-rust-governance</a></li><li><a href="1096-remove-static-assert.html">1096-remove-static-assert</a></li><li><a href="1102-rename-connect-to-join.html">1102-rename-connect-to-join</a></li><li><a href="1105-api-evolution.html">1105-api-evolution</a></li><li><a href="1119-result-expect.html">1119-result-expect</a></li><li><a href="1122-language-semver.html">1122-language-semver</a></li><li><a href="1123-str-split-at.html">1123-str-split-at</a></li><li><a href="1131-likely-intrinsic.html">1131-likely-intrinsic</a></li><li><a href="1135-raw-pointer-comparisons.html">1135-raw-pointer-comparisons</a></li><li><a href="1152-slice-string-symmetry.html">1152-slice-string-symmetry</a></li><li><a href="1156-adjust-default-object-bounds.html">1156-adjust-default-object-bounds</a></li><li><a href="1174-into-raw-fd-socket-handle-traits.html">1174-into-raw-fd-socket-handle-traits</a></li><li><a href="1183-swap-out-jemalloc.html">1183-swap-out-jemalloc</a></li><li><a href="1184-stabilize-no_std.html">1184-stabilize-no_std</a></li><li><a href="1191-hir.html">1191-hir</a></li><li><a href="1192-inclusive-ranges.html">1192-inclusive-ranges</a></li><li><a href="1193-cap-lints.html">1193-cap-lints</a></li><li><a href="1194-set-recovery.html">1194-set-recovery</a></li><li><a href="1199-simd-infrastructure.html">1199-simd-infrastructure</a></li><li><a href="1200-cargo-install.html">1200-cargo-install</a></li><li><a href="1201-naked-fns.html">1201-naked-fns</a></li><li><a href="1210-impl-specialization.html">1210-impl-specialization</a></li><li><a href="1211-mir.html">1211-mir</a></li><li><a href="1212-line-endings.html">1212-line-endings</a></li><li><a href="1214-projections-lifetimes-and-wf.html">1214-projections-lifetimes-and-wf</a></li><li><a href="1216-bang-type.html">1216-bang-type</a></li><li><a href="1219-use-group-as.html">1219-use-group-as</a></li><li><a href="1228-placement-left-arrow.html">1228-placement-left-arrow</a></li><li><a href="1229-compile-time-asserts.html">1229-compile-time-asserts</a></li><li><a href="1236-stabilize-catch-panic.html">1236-stabilize-catch-panic</a></li><li><a href="1238-nonparametric-dropck.html">1238-nonparametric-dropck</a></li><li><a href="1240-repr-packed-unsafe-ref.html">1240-repr-packed-unsafe-ref</a></li><li><a href="1241-no-wildcard-deps.html">1241-no-wildcard-deps</a></li><li><a href="1242-rust-lang-crates.html">1242-rust-lang-crates</a></li><li><a href="1252-open-options.html">1252-open-options</a></li><li><a href="1257-drain-range-2.html">1257-drain-range-2</a></li><li><a href="1260-main-reexport.html">1260-main-reexport</a></li><li><a href="1268-allow-overlapping-impls-on-marker-traits.html">1268-allow-overlapping-impls-on-marker-traits</a></li><li><a href="1270-deprecation.html">1270-deprecation</a></li><li><a href="1288-time-improvements.html">1288-time-improvements</a></li><li><a href="1291-promote-libc.html">1291-promote-libc</a></li><li><a href="1298-incremental-compilation.html">1298-incremental-compilation</a></li><li><a href="1300-intrinsic-semantics.html">1300-intrinsic-semantics</a></li><li><a href="1307-osstring-methods.html">1307-osstring-methods</a></li><li><a href="1317-ide.html">1317-ide</a></li><li><a href="1327-dropck-param-eyepatch.html">1327-dropck-param-eyepatch</a></li><li><a href="1328-global-panic-handler.html">1328-global-panic-handler</a></li><li><a href="1331-grammar-is-canonical.html">1331-grammar-is-canonical</a></li><li><a href="1358-repr-align.html">1358-repr-align</a></li><li><a href="1359-process-ext-unix.html">1359-process-ext-unix</a></li><li><a href="1361-cargo-cfg-dependencies.html">1361-cargo-cfg-dependencies</a></li><li><a href="1398-kinds-of-allocators.html">1398-kinds-of-allocators</a></li><li><a href="1399-repr-pack.html">1399-repr-pack</a></li><li><a href="1414-rvalue_static_promotion.html">1414-rvalue_static_promotion</a></li><li><a href="1415-trim-std-os.html">1415-trim-std-os</a></li><li><a href="1419-slice-copy.html">1419-slice-copy</a></li><li><a href="1422-pub-restricted.html">1422-pub-restricted</a></li><li><a href="1432-replace-slice.html">1432-replace-slice</a></li><li><a href="1434-contains-method-for-ranges.html">1434-contains-method-for-ranges</a></li><li><a href="1440-drop-types-in-const.html">1440-drop-types-in-const</a></li><li><a href="1443-extended-compare-and-swap.html">1443-extended-compare-and-swap</a></li><li><a href="1444-union.html">1444-union</a></li><li><a href="1445-restrict-constants-in-patterns.html">1445-restrict-constants-in-patterns</a></li><li><a href="1461-net2-mutators.html">1461-net2-mutators</a></li><li><a href="1467-volatile.html">1467-volatile</a></li><li><a href="1479-unix-socket.html">1479-unix-socket</a></li><li><a href="1492-dotdot-in-patterns.html">1492-dotdot-in-patterns</a></li><li><a href="1498-ipv6addr-octets.html">1498-ipv6addr-octets</a></li><li><a href="1504-int128.html">1504-int128</a></li><li><a href="1506-adt-kinds.html">1506-adt-kinds</a></li><li><a href="1510-cdylib.html">1510-cdylib</a></li><li><a href="1513-less-unwinding.html">1513-less-unwinding</a></li><li><a href="1521-copy-clone-semantics.html">1521-copy-clone-semantics</a></li><li><a href="1522-conservative-impl-trait.html">1522-conservative-impl-trait</a></li><li><a href="1525-cargo-workspace.html">1525-cargo-workspace</a></li><li><a href="1535-stable-overflow-checks.html">1535-stable-overflow-checks</a></li><li><a href="1542-try-from.html">1542-try-from</a></li><li><a href="1543-integer_atomics.html">1543-integer_atomics</a></li><li><a href="1548-global-asm.html">1548-global-asm</a></li><li><a href="1552-contains-method-for-various-collections.html">1552-contains-method-for-various-collections</a></li><li><a href="1558-closure-to-fn-coercion.html">1558-closure-to-fn-coercion</a></li><li><a href="1559-attributes-with-literals.html">1559-attributes-with-literals</a></li><li><a href="1560-name-resolution.html">1560-name-resolution</a></li><li><a href="1561-macro-naming.html">1561-macro-naming</a></li><li><a href="1566-proc-macros.html">1566-proc-macros</a></li><li><a href="1567-long-error-codes-explanation-normalization.html">1567-long-error-codes-explanation-normalization</a></li><li><a href="1574-more-api-documentation-conventions.html">1574-more-api-documentation-conventions</a></li><li><a href="1576-macros-literal-matcher.html">1576-macros-literal-matcher</a></li><li><a href="1581-fused-iterator.html">1581-fused-iterator</a></li><li><a href="1584-macros.html">1584-macros</a></li><li><a href="1589-rustc-bug-fix-procedure.html">1589-rustc-bug-fix-procedure</a></li><li><a href="1590-macro-lifetimes.html">1590-macro-lifetimes</a></li><li><a href="1598-generic_associated_types.html">1598-generic_associated_types</a></li><li><a href="1607-style-rfcs.html">1607-style-rfcs</a></li><li><a href="1618-ergonomic-format-args.html">1618-ergonomic-format-args</a></li><li><a href="1620-regex-1.0.html">1620-regex-1.0</a></li><li><a href="1623-static.html">1623-static</a></li><li><a href="1624-loop-break-value.html">1624-loop-break-value</a></li><li><a href="1636-document_all_features.html">1636-document_all_features</a></li><li><a href="1640-duration-checked-sub.html">1640-duration-checked-sub</a></li><li><a href="1643-memory-model-strike-team.html">1643-memory-model-strike-team</a></li><li><a href="1644-default-and-expanded-rustc-errors.html">1644-default-and-expanded-rustc-errors</a></li><li><a href="1647-allow-self-in-where-clauses.html">1647-allow-self-in-where-clauses</a></li><li><a href="1649-atomic-access.html">1649-atomic-access</a></li><li><a href="1651-movecell.html">1651-movecell</a></li><li><a href="1653-assert_ne.html">1653-assert_ne</a></li><li><a href="1660-try-borrow.html">1660-try-borrow</a></li><li><a href="1665-windows-subsystem.html">1665-windows-subsystem</a></li><li><a href="1679-panic-safe-slicing.html">1679-panic-safe-slicing</a></li><li><a href="1681-macros-1.1.html">1681-macros-1.1</a></li><li><a href="1682-field-init-shorthand.html">1682-field-init-shorthand</a></li><li><a href="1683-docs-team.html">1683-docs-team</a></li><li><a href="1685-deprecate-anonymous-parameters.html">1685-deprecate-anonymous-parameters</a></li><li><a href="1695-add-error-macro.html">1695-add-error-macro</a></li><li><a href="1696-discriminant.html">1696-discriminant</a></li><li><a href="1717-dllimport.html">1717-dllimport</a></li><li><a href="1721-crt-static.html">1721-crt-static</a></li><li><a href="1725-unaligned-access.html">1725-unaligned-access</a></li><li><a href="1728-north-star.html">1728-north-star</a></li><li><a href="1733-trait-alias.html">1733-trait-alias</a></li><li><a href="1758-repr-transparent.html">1758-repr-transparent</a></li><li><a href="1774-roadmap-2017.html">1774-roadmap-2017</a></li><li><a href="1789-as-cell.html">1789-as-cell</a></li><li><a href="1824-crates.io-default-ranking.html">1824-crates.io-default-ranking</a></li><li><a href="1826-change-doc-default-urls.html">1826-change-doc-default-urls</a></li><li><a href="1828-rust-bookshelf.html">1828-rust-bookshelf</a></li><li><a href="1845-shared-from-slice.html">1845-shared-from-slice</a></li><li><a href="1849-non-static-type-id.html">1849-non-static-type-id</a></li><li><a href="1857-stabilize-drop-order.html">1857-stabilize-drop-order</a></li><li><a href="1859-try-trait.html">1859-try-trait</a></li><li><a href="1860-manually-drop.html">1860-manually-drop</a></li><li><a href="1861-extern-types.html">1861-extern-types</a></li><li><a href="1866-more-readable-assert-eq.html">1866-more-readable-assert-eq</a></li><li><a href="1868-portability-lint.html">1868-portability-lint</a></li><li><a href="1869-eprintln.html">1869-eprintln</a></li><li><a href="1884-unstable-sort.html">1884-unstable-sort</a></li><li><a href="1892-uninitialized-uninhabited.html">1892-uninitialized-uninhabited</a></li><li><a href="1909-unsized-rvalues.html">1909-unsized-rvalues</a></li><li><a href="1925-optional-match-vert.html">1925-optional-match-vert</a></li><li><a href="1937-ques-in-main.html">1937-ques-in-main</a></li><li><a href="1940-must-use-functions.html">1940-must-use-functions</a></li><li><a href="1946-intra-rustdoc-links.html">1946-intra-rustdoc-links</a></li><li><a href="1951-expand-impl-trait.html">1951-expand-impl-trait</a></li><li><a href="1961-clamp.html">1961-clamp</a></li><li><a href="1966-unsafe-pointer-reform.html">1966-unsafe-pointer-reform</a></li><li><a href="1969-cargo-prepublish.html">1969-cargo-prepublish</a></li><li><a href="1974-global-allocators.html">1974-global-allocators</a></li><li><a href="1977-public-private-dependencies.html">1977-public-private-dependencies</a></li><li><a href="1983-nursery-deprecation.html">1983-nursery-deprecation</a></li><li><a href="1985-tiered-browser-support.html">1985-tiered-browser-support</a></li><li><a href="1990-external-doc-attribute.html">1990-external-doc-attribute</a></li><li><a href="2000-const-generics.html">2000-const-generics</a></li><li><a href="2005-match-ergonomics.html">2005-match-ergonomics</a></li><li><a href="2008-non-exhaustive.html">2008-non-exhaustive</a></li><li><a href="2011-generic-assert.html">2011-generic-assert</a></li><li><a href="2025-nested-method-calls.html">2025-nested-method-calls</a></li><li><a href="2027-object_safe_for_dispatch.html">2027-object_safe_for_dispatch</a></li><li><a href="2033-experimental-coroutines.html">2033-experimental-coroutines</a></li><li><a href="2043-is-aligned-intrinsic.html">2043-is-aligned-intrinsic</a></li><li><a href="2044-license-rfcs.html">2044-license-rfcs</a></li><li><a href="2045-target-feature.html">2045-target-feature</a></li><li><a href="2046-label-break-value.html">2046-label-break-value</a></li><li><a href="2052-epochs.html">2052-epochs</a></li><li><a href="2056-allow-trivial-where-clause-constraints.html">2056-allow-trivial-where-clause-constraints</a></li><li><a href="2057-refcell-replace.html">2057-refcell-replace</a></li><li><a href="2070-panic-implementation.html">2070-panic-implementation</a></li><li><a href="2071-impl-trait-existential-types.html">2071-impl-trait-existential-types</a></li><li><a href="2071-impl-trait-type-alias.html">2071-impl-trait-type-alias</a></li><li><a href="2086-allow-if-let-irrefutables.html">2086-allow-if-let-irrefutables</a></li><li><a href="2089-implied-bounds.html">2089-implied-bounds</a></li><li><a href="2091-inline-semantic.html">2091-inline-semantic</a></li><li><a href="2093-infer-outlives.html">2093-infer-outlives</a></li><li><a href="2094-nll.html">2094-nll</a></li><li><a href="2102-unnamed-fields.html">2102-unnamed-fields</a></li><li><a href="2103-tool-attributes.html">2103-tool-attributes</a></li><li><a href="2113-dyn-trait-syntax.html">2113-dyn-trait-syntax</a></li><li><a href="2115-argument-lifetimes.html">2115-argument-lifetimes</a></li><li><a href="2116-alloc-me-maybe.html">2116-alloc-me-maybe</a></li><li><a href="2124-option-filter.html">2124-option-filter</a></li><li><a href="2126-path-clarity.html">2126-path-clarity</a></li><li><a href="2128-use-nested-groups.html">2128-use-nested-groups</a></li><li><a href="2132-copy-closures.html">2132-copy-closures</a></li><li><a href="2133-all-the-clones.html">2133-all-the-clones</a></li><li><a href="2136-build-systems.html">2136-build-systems</a></li><li><a href="2137-variadic.html">2137-variadic</a></li><li><a href="2141-alternative-registries.html">2141-alternative-registries</a></li><li><a href="2145-type-privacy.html">2145-type-privacy</a></li><li><a href="2151-raw-identifiers.html">2151-raw-identifiers</a></li><li><a href="2166-impl-only-use.html">2166-impl-only-use</a></li><li><a href="2169-euclidean-modulo.html">2169-euclidean-modulo</a></li><li><a href="2175-if-while-or-patterns.html">2175-if-while-or-patterns</a></li><li><a href="2195-really-tagged-unions.html">2195-really-tagged-unions</a></li><li><a href="2196-metabuild.html">2196-metabuild</a></li><li><a href="2203-const-repeat-expr.html">2203-const-repeat-expr</a></li><li><a href="2226-fmt-debug-hex.html">2226-fmt-debug-hex</a></li><li><a href="2229-capture-disjoint-fields.html">2229-capture-disjoint-fields</a></li><li><a href="2230-bury-description.html">2230-bury-description</a></li><li><a href="2235-libc-struct-traits.html">2235-libc-struct-traits</a></li><li><a href="2250-finalize-impl-dyn-syntax.html">2250-finalize-impl-dyn-syntax</a></li><li><a href="2282-profile-dependencies.html">2282-profile-dependencies</a></li><li><a href="2289-associated-type-bounds.html">2289-associated-type-bounds</a></li><li><a href="2294-if-let-guard.html">2294-if-let-guard</a></li><li><a href="2295-os-str-pattern.html">2295-os-str-pattern</a></li><li><a href="2296-option-replace.html">2296-option-replace</a></li><li><a href="2298-macro-at-most-once-rep.html">2298-macro-at-most-once-rep</a></li><li><a href="2300-self-in-typedefs.html">2300-self-in-typedefs</a></li><li><a href="2302-tuple-struct-self-ctor.html">2302-tuple-struct-self-ctor</a></li><li><a href="2306-convert-id.html">2306-convert-id</a></li><li><a href="2307-concrete-nonzero-types.html">2307-concrete-nonzero-types</a></li><li><a href="2314-roadmap-2018.html">2314-roadmap-2018</a></li><li><a href="2318-custom-test-frameworks.html">2318-custom-test-frameworks</a></li><li><a href="2325-stable-simd.html">2325-stable-simd</a></li><li><a href="2333-prior-art.html">2333-prior-art</a></li><li><a href="2338-type-alias-enum-variants.html">2338-type-alias-enum-variants</a></li><li><a href="2341-const-locals.html">2341-const-locals</a></li><li><a href="2342-const-control-flow.html">2342-const-control-flow</a></li><li><a href="2344-const-looping.html">2344-const-looping</a></li><li><a href="2345-const-panic.html">2345-const-panic</a></li><li><a href="2349-pin.html">2349-pin</a></li><li><a href="2351-is-sorted.html">2351-is-sorted</a></li><li><a href="2359-subslice-pattern-syntax.html">2359-subslice-pattern-syntax</a></li><li><a href="2360-bench-black-box.html">2360-bench-black-box</a></li><li><a href="2361-dbg-macro.html">2361-dbg-macro</a></li><li><a href="2363-arbitrary-enum-discriminant.html">2363-arbitrary-enum-discriminant</a></li><li><a href="2383-lint-reasons.html">2383-lint-reasons</a></li><li><a href="2386-used.html">2386-used</a></li><li><a href="2388-try-expr.html">2388-try-expr</a></li><li><a href="2394-async_await.html">2394-async_await</a></li><li><a href="2397-do-not-recommend.html">2397-do-not-recommend</a></li><li><a href="2412-optimize-attr.html">2412-optimize-attr</a></li><li><a href="2420-unreserve-proc.html">2420-unreserve-proc</a></li><li><a href="2421-unreservations-2018.html">2421-unreservations-2018</a></li><li><a href="2436-style-guide.html">2436-style-guide</a></li><li><a href="2437-rustfmt-stability.html">2437-rustfmt-stability</a></li><li><a href="2438-deny-integer-literal-overflow-lint.html">2438-deny-integer-literal-overflow-lint</a></li><li><a href="2451-re-rebalancing-coherence.html">2451-re-rebalancing-coherence</a></li><li><a href="2457-non-ascii-idents.html">2457-non-ascii-idents</a></li><li><a href="2471-lint-test-inner-function.html">2471-lint-test-inner-function</a></li><li><a href="2476-clippy-uno.html">2476-clippy-uno</a></li><li><a href="2480-liballoc.html">2480-liballoc</a></li><li><a href="2495-min-rust-version.html">2495-min-rust-version</a></li><li><a href="2497-if-let-chains.html">2497-if-let-chains</a></li><li><a href="2500-needle.html">2500-needle</a></li><li><a href="2504-fix-error.html">2504-fix-error</a></li><li><a href="2514-union-initialization-and-drop.html">2514-union-initialization-and-drop</a></li><li><a href="2515-type_alias_impl_trait.html">2515-type_alias_impl_trait</a></li><li><a href="2521-c_void-reunification.html">2521-c_void-reunification</a></li><li><a href="2523-cfg-path-version.html">2523-cfg-path-version</a></li><li><a href="2526-const-wildcard.html">2526-const-wildcard</a></li><li><a href="2532-associated-type-defaults.html">2532-associated-type-defaults</a></li><li><a href="2535-or-patterns.html">2535-or-patterns</a></li><li><a href="2539-cfg_attr-multiple-attrs.html">2539-cfg_attr-multiple-attrs</a></li><li><a href="2561-future-possibilities.html">2561-future-possibilities</a></li><li><a href="2565-formal-function-parameter-attributes.html">2565-formal-function-parameter-attributes</a></li><li><a href="2570-linked-list-cursors.html">2570-linked-list-cursors</a></li><li><a href="2574-simd-ffi.html">2574-simd-ffi</a></li><li><a href="2582-raw-reference-mir-operator.html">2582-raw-reference-mir-operator</a></li><li><a href="2591-exhaustive-integer-pattern-matching.html">2591-exhaustive-integer-pattern-matching</a></li><li><a href="2592-futures.html">2592-futures</a></li><li><a href="2603-symbol-name-mangling-v2.html">2603-symbol-name-mangling-v2</a></li><li><a href="2627-raw-dylib-kind.html">2627-raw-dylib-kind</a></li><li><a href="2645-transparent-unions.html">2645-transparent-unions</a></li><li><a href="2657-roadmap-2019.html">2657-roadmap-2019</a></li><li><a href="2678-named-custom-cargo-profiles.html">2678-named-custom-cargo-profiles</a></li><li><a href="2689-compiler-team-contributors.html">2689-compiler-team-contributors</a></li><li><a href="2696-debug-map-key-value.html">2696-debug-map-key-value</a></li><li><a href="2700-associated-constants-on-ints.html">2700-associated-constants-on-ints</a></li><li><a href="2707-dotdot-patterns.html">2707-dotdot-patterns</a></li><li><a href="2795-format-args-implicit-identifiers.html">2795-format-args-implicit-identifiers</a></li><li><a href="2797-project-ffi-unwind.html">2797-project-ffi-unwind</a></li><li><a href="2835-project-safe-transmute.html">2835-project-safe-transmute</a></li><li><a href="2837-demote-apple-32bit.html">2837-demote-apple-32bit</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust RFC Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li>Start Date: 2014-08-04</li>
<li>RFC PR #: <a href="https://github.com/rust-lang/rfcs/pull/195">rust-lang/rfcs#195</a></li>
<li>Rust Issue #: <a href="https://github.com/rust-lang/rust/issues/17307">rust-lang/rust#17307</a></li>
</ul>
<a class="header" href="#summary" id="summary"><h1>Summary</h1></a>
<p>This RFC extends traits with <em>associated items</em>, which make generic programming
more convenient, scalable, and powerful. In particular, traits will consist of a
set of methods, together with:</p>
<ul>
<li>Associated functions (already present as &quot;static&quot; functions)</li>
<li>Associated consts</li>
<li>Associated types</li>
<li>Associated lifetimes</li>
</ul>
<p>These additions make it much easier to group together a set of related types,
functions, and constants into a single package.</p>
<p>This RFC also provides a mechanism for <em>multidispatch</em> traits, where the <code>impl</code>
is selected based on multiple types. The connection to associated items will
become clear in the detailed text below.</p>
<p><em>Note: This RFC was originally accepted before RFC 246 introduced the
distinction between const and static items. The text has been updated to clarify
that associated consts will be added rather than statics, and to provide a
summary of restrictions on the initial implementation of associated
consts. Other than that modification, the proposal has not been changed to
reflect newer Rust features or syntax.</em></p>
<a class="header" href="#motivation" id="motivation"><h1>Motivation</h1></a>
<p>A typical example where associated items are helpful is data structures like
graphs, which involve at least three types: nodes, edges, and the graph itself.</p>
<p>In today's Rust, to capture graphs as a generic trait, you have to take the
additional types associated with a graph as <em>parameters</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    ...
}
#}</code></pre></pre>
<p>The fact that the node and edge types are parameters is confusing, since any
concrete graph type is associated with a <em>unique</em> node and edge type. It is also
inconvenient, because code working with generic graphs is likewise forced to
parameterize, even when not all of the types are relevant:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; uint { ... }
#}</code></pre></pre>
<p>With associated types, the graph trait can instead make clear that the node and
edge types are determined by any <code>impl</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
    type N;
    type E;
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
}
#}</code></pre></pre>
<p>and clients can abstract over them all at once, referring to them through the
graph type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint { ... }
#}</code></pre></pre>
<p>The following subsections expand on the above benefits of associated items, as
well as some others.</p>
<a class="header" href="#associated-types-engineering-benefits-for-generics" id="associated-types-engineering-benefits-for-generics"><h2>Associated types: engineering benefits for generics</h2></a>
<p>As the graph example above illustrates, associated <em>types</em> do not increase the
expressiveness of traits <em>per se</em>, because you can always use extra type
parameters to a trait instead. However, associated types provide several
engineering benefits:</p>
<ul>
<li>
<p><strong>Readability and scalability</strong></p>
<p>Associated types make it possible to abstract over a whole family of types at
once, without having to separately name each of them. This improves the
readability of generic code (like the <code>distance</code> function above).  It also
makes generics more &quot;scalable&quot;: traits can incorporate additional associated
types without imposing an extra burden on clients that don't care about those
types.</p>
<p>In today's Rust, by contrast, adding additional generic parameters to a
trait often feels like a very &quot;heavyweight&quot; move.</p>
</li>
<li>
<p><strong>Ease of refactoring/evolution</strong></p>
<p>Because users of a trait do not have to separately parameterize over its
associated types, new associated types can be added without breaking all
existing client code.</p>
<p>In today's Rust, by contrast, associated types can only be added by adding
more type parameters to a trait, which breaks all code mentioning the trait.</p>
</li>
</ul>
<a class="header" href="#clearer-trait-matching" id="clearer-trait-matching"><h2>Clearer trait matching</h2></a>
<p>Type parameters to traits can either be &quot;inputs&quot; or &quot;outputs&quot;:</p>
<ul>
<li>
<p><strong>Inputs</strong>. An &quot;input&quot; type parameter is used to <em>determine</em> which <code>impl</code> to
use.</p>
</li>
<li>
<p><strong>Outputs</strong>. An &quot;output&quot; type parameter is uniquely determined <em>by</em> the
<code>impl</code>, but plays no role in selecting the <code>impl</code>.</p>
</li>
</ul>
<p>Input and output types play an important role for type inference and trait
coherence rules, which is described in more detail later on.</p>
<p>In the vast majority of current libraries, the only input type is the <code>Self</code>
type implementing the trait, and all other trait type parameters are outputs.
For example, the trait <code>Iterator&lt;A&gt;</code> takes a type parameter <code>A</code> for the elements
being iterated over, but this type is always determined by the concrete <code>Self</code>
type (e.g. <code>Items&lt;u8&gt;</code>) implementing the trait: <code>A</code> is typically an output.</p>
<p>Additional input type parameters are useful for cases like binary operators,
where you may want the <code>impl</code> to depend on the types of <em>both</em>
arguments. For example, you might want a trait</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;Rhs, Sum&gt; {
    fn add(&amp;self, rhs: &amp;Rhs) -&gt; Sum;
}
#}</code></pre></pre>
<p>to view the <code>Self</code> and <code>Rhs</code> types as inputs, and the <code>Sum</code> type as an output
(since it is uniquely determined by the argument types). This would allow
<code>impl</code>s to vary depending on the <code>Rhs</code> type, even though the <code>Self</code> type is the same:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Add&lt;int, int&gt; for int { ... }
impl Add&lt;Complex, Complex&gt; for int { ... }
#}</code></pre></pre>
<p>Today's Rust does not make a clear distinction between input and output type
parameters to traits. If you attempted to provide the two <code>impl</code>s above, you
would receive an error like:</p>
<pre><code>error: conflicting implementations for trait `Add`
</code></pre>
<p>This RFC clarifies trait matching by:</p>
<ul>
<li>Treating all trait type parameters as <em>input</em> types, and</li>
<li>Providing associated types, which are <em>output</em> types.</li>
</ul>
<p>In this design, the <code>Add</code> trait would be written and implemented as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Self and Rhs are *inputs*
trait Add&lt;Rhs&gt; {
    type Sum; // Sum is an *output*
    fn add(&amp;self, &amp;Rhs) -&gt; Sum;
}

impl Add&lt;int&gt; for int {
    type Sum = int;
    fn add(&amp;self, rhs: &amp;int) -&gt; int { ... }
}

impl Add&lt;Complex&gt; for int {
    type Sum = Complex;
    fn add(&amp;self, rhs: &amp;Complex) -&gt; Complex { ... }
}
#}</code></pre></pre>
<p>With this approach, a trait declaration like <code>trait Add&lt;Rhs&gt; { ... }</code> is really
defining a <em>family</em> of traits, one for each choice of <code>Rhs</code>. One can then
provide a distinct <code>impl</code> for every member of this family.</p>
<a class="header" href="#expressiveness" id="expressiveness"><h2>Expressiveness</h2></a>
<p>Associated types, lifetimes, and functions can already be expressed in today's
Rust, though it is unwieldy to do so (as argued above).</p>
<p>But associated <em>consts</em> cannot be expressed using today's traits.</p>
<p>For example, today's Rust includes a variety of numeric traits, including
<code>Float</code>, which must currently expose constants as static functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Float {
    fn nan() -&gt; Self;
    fn infinity() -&gt; Self;
    fn neg_infinity() -&gt; Self;
    fn neg_zero() -&gt; Self;
    fn pi() -&gt; Self;
    fn two_pi() -&gt; Self;
    ...
}
#}</code></pre></pre>
<p>Because these functions cannot be used in constant expressions, the modules for
float types <em>also</em> export a separate set of constants as consts, not using
traits.</p>
<p>Associated constants would allow the consts to live directly on the traits:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Float {
    const NAN: Self;
    const INFINITY: Self;
    const NEG_INFINITY: Self;
    const NEG_ZERO: Self;
    const PI: Self;
    const TWO_PI: Self;
    ...
}
#}</code></pre></pre>
<a class="header" href="#why-now" id="why-now"><h2>Why now?</h2></a>
<p>The above motivations aside, it may not be obvious why adding associated types
<em>now</em> (i.e., pre-1.0) is important. There are essentially two reasons.</p>
<p>First, the design presented here is <em>not</em> backwards compatible, because it
re-interprets trait type parameters as inputs for the purposes of trait
matching. The input/output distinction has several ramifications on coherence
rules, type inference, and resolution, which are all described later on in the
RFC.</p>
<p>Of course, it might be possible to give a somewhat less ideal design where
associated types can be added later on without changing the interpretation of
existing trait type parameters. For example, type parameters could be explicitly
marked as inputs, and otherwise assumed to be outputs. That would be
unfortunate, since associated types would <em>also</em> be outputs -- leaving the
language with two ways of specifying output types for traits.</p>
<p>But the second reason is for the library stabilization process:</p>
<ul>
<li>
<p>Since most existing uses of trait type parameters are intended as outputs,
they should really be associated types instead. Making promises about these APIs
as they currently stand risks locking the libraries into a design that will seem
obsolete as soon as associated items are added. Again, this risk could probably
be mitigated with a different, backwards-compatible associated item design, but
at the cost of cruft in the language itself.</p>
</li>
<li>
<p>The binary operator traits (e.g. <code>Add</code>) should be multidispatch. It does not
seem possible to stabilize them <em>now</em> in a way that will support moving to
multidispatch later.</p>
</li>
<li>
<p>There are some thorny problems in the current libraries, such as the <code>_equiv</code>
methods accumulating in <code>HashMap</code>, that can be solved using associated
items. (See &quot;Defaults&quot; below for more on this specific example.) Additional
examples include traits for error propagation and for conversion (to be
covered in future RFCs). Adding these traits would improve the quality and
consistency of our 1.0 library APIs.</p>
</li>
</ul>
<a class="header" href="#detailed-design" id="detailed-design"><h1>Detailed design</h1></a>
<a class="header" href="#trait-headers" id="trait-headers"><h2>Trait headers</h2></a>
<p>Trait headers are written according to the following grammar:</p>
<pre><code>TRAIT_HEADER =
  'trait' IDENT [ '&lt;' INPUT_PARAMS '&gt;' ] [ ':' BOUNDS ] [ WHERE_CLAUSE ]

INPUT_PARAMS = INPUT_TY { ',' INPUT_TY }* [ ',' ]
INPUT_PARAM  = IDENT [ ':' BOUNDS ]

BOUNDS = BOUND { '+' BOUND }* [ '+' ]
BOUND  = IDENT [ '&lt;' ARGS '&gt;' ]

ARGS   = INPUT_ARGS
       | OUTPUT_CONSTRAINTS
       | INPUT_ARGS ',' OUTPUT_CONSTRAINTS

INPUT_ARGS = TYPE { ',' TYPE }*

OUTPUT_CONSTRAINTS = OUTPUT_CONSTRAINT { ',' OUTPUT_CONSTRAINT }*
OUTPUT_CONSTRAINT  = IDENT '=' TYPE
</code></pre>
<p><strong>NOTE</strong>: The grammar for <code>WHERE_CLAUSE</code> and <code>BOUND</code> is explained in detail in
the subsection &quot;Constraining associated types&quot; below.</p>
<p>All type parameters to a trait are considered inputs, and can be used to select
an <code>impl</code>; conceptually, each distinct instantiation of the types yields a
distinct trait. More details are given in the section &quot;The input/output type
distinction&quot; below.</p>
<a class="header" href="#trait-bodies-defining-associated-items" id="trait-bodies-defining-associated-items"><h2>Trait bodies: defining associated items</h2></a>
<p>Trait bodies are expanded to include three new kinds of items: consts, types,
and lifetimes:</p>
<pre><code>TRAIT = TRAIT_HEADER '{' TRAIT_ITEM* '}'
TRAIT_ITEM =
  ... &lt;existing productions&gt;
  | 'const' IDENT ':' TYPE [ '=' CONST_EXP ] ';'
  | 'type' IDENT [ ':' BOUNDS ] [ WHERE_CLAUSE ] [ '=' TYPE ] ';'
  | 'lifetime' LIFETIME_IDENT ';'
</code></pre>
<p>Traits already support associated functions, which had previously been called
&quot;static&quot; functions.</p>
<p>The <code>BOUNDS</code> and <code>WHERE_CLAUSE</code> on associated types are <em>obligations</em> for the
implementor of the trait, and <em>assumptions</em> for users of the trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
    type N: Show + Hash;
    type E: Show + Hash;
    ...
}

impl Graph for MyGraph {
    // Both MyNode and MyEdge must implement Show and Hash
    type N = MyNode;
    type E = MyEdge;
    ...
}

fn print_nodes&lt;G: Graph&gt;(g: &amp;G) {
    // here, can assume G::N implements Show
    ...
}
#}</code></pre></pre>
<a class="header" href="#namespacingshadowing-for-associated-types" id="namespacingshadowing-for-associated-types"><h3>Namespacing/shadowing for associated types</h3></a>
<p>Associated types may have the same name as existing types in scope, <em>except</em> for
type parameters to the trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo { ... }

trait Bar&lt;Input&gt; {
    type Foo; // this is allowed
    fn into_foo(self) -&gt; Foo; // this refers to the trait's Foo

    type Input; // this is NOT allowed
}
#}</code></pre></pre>
<p>By not allowing name clashes between input and output types,
keep open the possibility of later allowing syntax like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Bar&lt;Input=u8, Foo=uint&gt;
#}</code></pre></pre>
<p>where both input and output parameters are constrained by name. And anyway,
there is no use for clashing input/output names.</p>
<p>In the case of a name clash like <code>Foo</code> above, if the trait needs to refer to the
outer <code>Foo</code> for some reason, it can always do so by using a <code>type</code> alias
external to the trait.</p>
<a class="header" href="#defaults" id="defaults"><h3>Defaults</h3></a>
<p>Notice that associated consts and types both permit defaults, just as trait
methods and functions can provide defaults.</p>
<p>Defaults are useful both as a code reuse mechanism, and as a way to expand the
items included in a trait without breaking all existing implementors of the
trait.</p>
<p>Defaults for associated types, however, present an interesting question: can
default methods assume the default type? In other words, is the following
allowed?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait ContainerKey : Clone + Hash + Eq {
    type Query: Hash = Self;
    fn compare(&amp;self, other: &amp;Query) -&gt; bool { self == other }
    fn query_to_key(q: &amp;Query) -&gt; Self { q.clone() };
}

impl ContainerKey for String {
    type Query = str;
    fn compare(&amp;self, other: &amp;str) -&gt; bool {
        self.as_slice() == other
    }
    fn query_to_key(q: &amp;str) -&gt; String {
        q.into_string()
    }
}

impl&lt;K,V&gt; HashMap&lt;K,V&gt; where K: ContainerKey {
    fn find(&amp;self, q: &amp;K::Query) -&gt; &amp;V { ... }
}
#}</code></pre></pre>
<p>In this example, the <code>ContainerKey</code> trait is used to associate a &quot;<code>Query</code>&quot; type
(for lookups) with an owned key type. This resolves the thorny &quot;equiv&quot; problem
in <code>HashMap</code>, where the hash map keys are <code>String</code>s but you want to index the
hash map with <code>&amp;str</code> values rather than <code>&amp;String</code> values, i.e. you want the
following to work:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// H: HashMap&lt;String, SomeType&gt;
H.find(&quot;some literal&quot;)
#}</code></pre></pre>
<p>rather than having to write</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
H.find(&amp;&quot;some literal&quot;.to_string())`
#}</code></pre></pre>
<p>The current solution involves duplicating the API surface with <code>_equiv</code> methods
that use the somewhat subtle <code>Equiv</code> trait, but the associated type approach
makes it easy to provide a simple, single API that covers the same use cases.</p>
<p>The defaults for <code>ContainerKey</code> just assume that the owned key and lookup key
types are the same, but the default methods have to assume the default
associated types in order to work.</p>
<p>For this to work, it must <em>not</em> be possible for an implementor of <code>ContainerKey</code>
to override the default <code>Query</code> type while leaving the default methods in place,
since those methods may no longer typecheck.</p>
<p>We deal with this in a very simple way:</p>
<ul>
<li>
<p>If a trait implementor overrides any default associated types, they must also
override <em>all</em> default functions and methods.</p>
</li>
<li>
<p>Otherwise, a trait implementor can selectively override individual default
methods/functions, as they can today.</p>
</li>
</ul>
<a class="header" href="#trait-implementations" id="trait-implementations"><h2>Trait implementations</h2></a>
<p>Trait <code>impl</code> syntax is much the same as before, except that const, type, and
lifetime items are allowed:</p>
<pre><code>IMPL_ITEM =
  ... &lt;existing productions&gt;
  | 'const' IDENT ':' TYPE '=' CONST_EXP ';'
  | 'type' IDENT' '=' 'TYPE' ';'
  | 'lifetime' LIFETIME_IDENT '=' LIFETIME_REFERENCE ';'
</code></pre>
<p>Any <code>type</code> implementation must satisfy all bounds and where clauses in the
corresponding trait item.</p>
<a class="header" href="#referencing-associated-items" id="referencing-associated-items"><h2>Referencing associated items</h2></a>
<p>Associated items are referenced through paths. The expression path grammar was
updated as part of <a href="https://github.com/rust-lang/rfcs/pull/132">UFCS</a>, but to
accommodate associated types and lifetimes we need to update the type path
grammar as well.</p>
<p>The full grammar is as follows:</p>
<pre><code>EXP_PATH
  = EXP_ID_SEGMENT { '::' EXP_ID_SEGMENT }*
  | TYPE_SEGMENT { '::' EXP_ID_SEGMENT }+
  | IMPL_SEGMENT { '::' EXP_ID_SEGMENT }+
EXP_ID_SEGMENT   = ID [ '::' '&lt;' TYPE { ',' TYPE }* '&gt;' ]

TY_PATH
  = TY_ID_SEGMENT { '::' TY_ID_SEGMENT }*
  | TYPE_SEGMENT { '::' TY_ID_SEGMENT }*
  | IMPL_SEGMENT { '::' TY_ID_SEGMENT }+

TYPE_SEGMENT = '&lt;' TYPE '&gt;'
IMPL_SEGMENT = '&lt;' TYPE 'as' TRAIT_REFERENCE '&gt;'
TRAIT_REFERENCE = ID [ '&lt;' TYPE { ',' TYPE * '&gt;' ]
</code></pre>
<p>Here are some example paths, along with what they might be referencing</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Expression paths ///////////////////////////////////////////////////////////////

a::b::c         // reference to a function `c` in module `a::b`
a::&lt;T1, T2&gt;     // the function `a` instantiated with type arguments `T1`, `T2`
Vec::&lt;T&gt;::new   // reference to the function `new` associated with `Vec&lt;T&gt;`
&lt;Vec&lt;T&gt; as SomeTrait&gt;::some_fn
                // reference to the function `some_fn` associated with `SomeTrait`,
                //   as implemented by `Vec&lt;T&gt;`
T::size_of      // the function `size_of` associated with the type or trait `T`
&lt;T&gt;::size_of    // the function `size_of` associated with `T` _viewed as a type_
&lt;T as SizeOf&gt;::size_of
                // the function `size_of` associated with `T`'s impl of `SizeOf`

// Type paths /////////////////////////////////////////////////////////////////////

a::b::C         // reference to a type `C` in module `a::b`
A&lt;T1, T2&gt;       // type A instantiated with type arguments `T1`, `T2`
Vec&lt;T&gt;::Iter    // reference to the type `Iter` associated with `Vec&lt;T&gt;
&lt;Vec&lt;T&gt; as SomeTrait&gt;::SomeType
                // reference to the type `SomeType` associated with `SomeTrait`,
                //   as implemented by `Vec&lt;T&gt;`
#}</code></pre></pre>
<a class="header" href="#ways-to-reference-items" id="ways-to-reference-items"><h3>Ways to reference items</h3></a>
<p>Next, we'll go into more detail on the meaning of each kind of path.</p>
<p>For the sake of discussion, we'll suppose we've defined a trait like the
following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, E);
    fn contains(&amp;self, &amp;E) -&gt; bool where E: PartialEq;
    ...
}

impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    ...
}
#}</code></pre></pre>
<a class="header" href="#via-an-id_segment-prefix" id="via-an-id_segment-prefix"><h4>Via an <code>ID_SEGMENT</code> prefix</h4></a>
<a class="header" href="#when-the-prefix-resolves-to-a-type" id="when-the-prefix-resolves-to-a-type"><h5>When the prefix resolves to a type</h5></a>
<p>The most common way to get at an associated item is through a type parameter
with a trait bound:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; { ... }

fn mk_with_two&lt;C&gt;() -&gt; C where C: Container, C::E = uint {
    let mut cont = C::empty();  // reference to associated function
    cont.insert(0);
    cont.insert(1);
    cont
}
#}</code></pre></pre>
<p>For these references to be valid, the type parameter must be known to implement
the relevant trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Knowledge via bounds
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; { ... }

// ... or equivalently,  where clause
fn pick&lt;C&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; where C: Container { ... }

// Knowledge via ambient constraints
struct TwoContainers&lt;C1: Container, C2: Container&gt;(C1, C2);
impl&lt;C1: Container, C2: Container&gt; TwoContainers&lt;C1, C2&gt; {
    fn pick_one(&amp;self) -&gt; Option&lt;&amp;C1::E&gt; { ... }
    fn pick_other(&amp;self) -&gt; Option&lt;&amp;C2::E&gt; { ... }
}
#}</code></pre></pre>
<p>Note that <code>Vec&lt;T&gt;::E</code> and <code>Vec::&lt;T&gt;::empty</code> are also valid type and function
references, respectively.</p>
<p>For cases like <code>C::E</code> or <code>Vec&lt;T&gt;::E</code>, the path begins with an <code>ID_SEGMENT</code>
prefix that itself resolves to a <em>type</em>: both <code>C</code> and <code>Vec&lt;T&gt;</code> are types.  In
general, a path <code>PREFIX::REST_OF_PATH</code> where <code>PREFIX</code> resolves to a type is
equivalent to using a <code>TYPE_SEGMENT</code> prefix <code>&lt;PREFIX&gt;::REST_OF_PATH</code>. So, for
example, following are all equivalent:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; { ... }
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;&lt;C&gt;::E&gt; { ... }
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;&lt;&lt;C&gt;::E&gt;&gt; { ... }
#}</code></pre></pre>
<p>The behavior of <code>TYPE_SEGMENT</code> prefixes is described in the next subsection.</p>
<a class="header" href="#when-the-prefix-resolves-to-a-trait" id="when-the-prefix-resolves-to-a-trait"><h5>When the prefix resolves to a trait</h5></a>
<p>However, it is possible for an <code>ID_SEGMENT</code> prefix to resolve to a <em>trait</em>,
rather than a type. In this case, the behavior of an <code>ID_SEGMENT</code> varies from
that of a <code>TYPE_SEGMENT</code> in the following way:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// a reference Container::insert is roughly equivalent to:
fn trait_insert&lt;C: Container&gt;(c: &amp;C, e: C::E);

// a reference &lt;Container&gt;::insert is roughly equivalent to:
fn object_insert&lt;E&gt;(c: &amp;Container&lt;E=E&gt;, e: E);
#}</code></pre></pre>
<p>That is, if <code>PREFIX</code> is an <code>ID_SEGMENT</code> that
resolves to a trait <code>Trait</code>:</p>
<ul>
<li>
<p>A path <code>PREFIX::REST</code> resolves to the item/path <code>REST</code> defined within
<code>Trait</code>, while treating the type implementing the trait as a type parameter.</p>
</li>
<li>
<p>A path <code>&lt;PREFIX&gt;::REST</code> treats <code>PREFIX</code> as a (DST-style) <em>type</em>, and is
hence usable only with trait objects. See the
<a href="https://github.com/rust-lang/rfcs/pull/132">UFCS RFC</a> for more detail.</p>
</li>
</ul>
<p>Note that a path like <code>Container::E</code>, while grammatically valid, will fail to
resolve since there is no way to tell which <code>impl</code> to use. A path like
<code>Container::empty</code>, however, resolves to a function roughly equivalent to:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn trait_empty&lt;C: Container&gt;() -&gt; C;
#}</code></pre></pre>
<a class="header" href="#via-a-type_segment-prefix" id="via-a-type_segment-prefix"><h4>Via a <code>TYPE_SEGMENT</code> prefix</h4></a>
<blockquote>
<p>The following text is <em>slightly changed</em> from the
<a href="https://github.com/rust-lang/rfcs/pull/132">UFCS RFC</a>.</p>
</blockquote>
<p>When a path begins with a <code>TYPE_SEGMENT</code>, it is a type-relative path. If this is
the complete path (e.g., <code>&lt;int&gt;</code>), then the path resolves to the specified
type. If the path continues (e.g., <code>&lt;int&gt;::size_of</code>) then the next segment is
resolved using the following procedure.  The procedure is intended to mimic
method lookup, and hence any changes to method lookup may also change the
details of this lookup.</p>
<p>Given a path <code>&lt;T&gt;::m::...</code>:</p>
<ol>
<li>
<p>Search for members of inherent impls defined on <code>T</code> (if any) with
the name <code>m</code>. If any are found, the path resolves to that item.</p>
</li>
<li>
<p>Otherwise, let <code>IN_SCOPE_TRAITS</code> be the set of traits that are in
scope and which contain a member named <code>m</code>:</p>
<ul>
<li>Let <code>IMPLEMENTED_TRAITS</code> be those traits from <code>IN_SCOPE_TRAITS</code>
for which an implementation exists that (may) apply to <code>T</code>.
<ul>
<li>There can be ambiguity in the case that <code>T</code> contains type inference
variables.</li>
</ul>
</li>
<li>If <code>IMPLEMENTED_TRAITS</code> is not a singleton set, report an ambiguity
error. Otherwise, let <code>TRAIT</code> be the member of <code>IMPLEMENTED_TRAITS</code>.</li>
<li>If <code>TRAIT</code> is ambiguously implemented for <code>T</code>, report an
ambiguity error and request further type information.</li>
<li>Otherwise, rewrite the path to <code>&lt;T as Trait&gt;::m::...</code> and
continue.</li>
</ul>
</li>
</ol>
<a class="header" href="#via-a-impl_segment-prefix" id="via-a-impl_segment-prefix"><h4>Via a <code>IMPL_SEGMENT</code> prefix</h4></a>
<blockquote>
<p>The following text is <em>somewhat different</em> from the
<a href="https://github.com/rust-lang/rfcs/pull/132">UFCS RFC</a>.</p>
</blockquote>
<p>When a path begins with an <code>IMPL_SEGMENT</code>, it is a reference to an item defined
from a trait. Note that such paths must always have a follow-on member <code>m</code> (that
is, <code>&lt;T as Trait&gt;</code> is not a complete path, but <code>&lt;T as Trait&gt;::m</code> is).</p>
<p>To resolve the path, first search for an applicable implementation of <code>Trait</code>
for <code>T</code>. If no implementation can be found -- or the result is ambiguous -- then
report an error.  Note that when <code>T</code> is a type parameter, a bound <code>T: Trait</code>
guarantees that there is such an implementation, but does not count for
ambiguity purposes.</p>
<p>Otherwise, resolve the path to the member of the trait with the substitution
<code>Self =&gt; T</code> and continue.</p>
<p>This apparently straightforward algorithm has some subtle consequences, as
illustrated by the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    type T;
    fn as_T(&amp;self) -&gt; &amp;T;
}

// A blanket impl for any Show type T
impl&lt;T: Show&gt; Foo for T {
    type T = T;
    fn as_T(&amp;self) -&gt; &amp;T { self }
}

fn bounded&lt;U: Foo&gt;(u: U) where U::T: Show {
    // Here, we just constrain the associated type directly
    println!(&quot;{}&quot;, u.as_T())
}

fn blanket&lt;U: Show&gt;(u: U) {
    // the blanket impl applies to U, so we know that `U: Foo` and
    // &lt;U as Foo&gt;::T = U (and, of course, U: Show)
    println!(&quot;{}&quot;, u.as_T())
}

fn not_allowed&lt;U: Foo&gt;(u: U) {
    // this will not compile, since &lt;U as Trait&gt;::T is not known to
    // implement Show
    println!(&quot;{}&quot;, u.as_T())
}
#}</code></pre></pre>
<p>This example includes three generic functions that make use of an associated
type; the first two will typecheck, while the third will not.</p>
<ul>
<li>
<p>The first case, <code>bounded</code>, places a <code>Show</code> constraint directly on the
otherwise-abstract associated type <code>U::T</code>. Hence, it is allowed to assume that
<code>U::T: Show</code>, even though it does not know the concrete implementation of
<code>Foo</code> for <code>U</code>.</p>
</li>
<li>
<p>The second case, <code>blanket</code>, places a <code>Show</code> constraint on the type <code>U</code>, which
means that the blanket <code>impl</code> of <code>Foo</code> applies even though we do not know the
<em>concrete</em> type that <code>U</code> will be. That fact means, moreover, that we can
compute exactly what the associated type <code>U::T</code> will be, and know that it will
satisfy <code>Show</code>. Coherence guarantees that that the blanket <code>impl</code> is the only
one that could apply to <code>U</code>. (See the section &quot;Impl specialization&quot; under
&quot;Unresolved questions&quot; for a deeper discussion of this point.)</p>
</li>
<li>
<p>The third case assumes only that <code>U: Foo</code>, and therefore nothing is known
about the associated type <code>U::T</code>. In particular, the function cannot assume
that <code>U::T: Show</code>.</p>
</li>
</ul>
<p>The resolution rules also interact with instantiation of type parameters in an
intuitive way. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
    type N;
    type E;
    ...
}

impl Graph for MyGraph {
    type N = MyNode;
    type E = MyEdge;
    ...
}

fn pick_node&lt;G: Graph&gt;(t: &amp;G) -&gt; &amp;G::N {
    // the type G::N is abstract here
    ...
}

let G = MyGraph::new();
...
pick_node(G) // has type: &lt;MyGraph as Graph&gt;::N = MyNode
#}</code></pre></pre>
<p>Assuming there are no blanket implementations of <code>Graph</code>, the <code>pick_node</code>
function knows nothing about the associated type <code>G::N</code>. However, a <em>client</em> of
<code>pick_node</code> that instantiates it with a particular concrete graph type will also
know the concrete type of the value returned from the function -- here, <code>MyNode</code>.</p>
<a class="header" href="#scoping-of-trait-and-impl-items" id="scoping-of-trait-and-impl-items"><h2>Scoping of <code>trait</code> and <code>impl</code> items</h2></a>
<p>Associated types are frequently referred to in the signatures of a trait's
methods and associated functions, and it is natural and convenient to refer to
them directly.</p>
<p>In other words, writing this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
    type N;
    type E;
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    ...
}
#}</code></pre></pre>
<p>is more appealing than writing this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
    type N;
    type E;
    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    ...
}
#}</code></pre></pre>
<p>This RFC proposes to treat both <code>trait</code> and <code>impl</code> bodies (both
inherent and for traits) the same way we treat <code>mod</code> bodies: <em>all</em>
items being defined are in scope. In particular, methods are in scope
as UFCS-style functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    type AssocType;
    lifetime 'assoc_lifetime;
    const ASSOC_CONST: uint;
    fn assoc_fn() -&gt; Self;

    // Note: 'assoc_lifetime and AssocType in scope:
    fn method(&amp;self, Self) -&gt; &amp;'assoc_lifetime AssocType;

    fn default_method(&amp;self) -&gt; uint {
        // method in scope UFCS-style, assoc_fn in scope
        let _ = method(self, assoc_fn());
        ASSOC_CONST // in scope
    }
}

// Same scoping rules for impls, including inherent impls:
struct Bar;
impl Bar {
    fn foo(&amp;self) { ... }
    fn bar(&amp;self) {
        foo(self); // foo in scope UFCS-style
        ...
    }
}
#}</code></pre></pre>
<p>Items from super traits are <em>not</em> in scope, however. See
<a href="#super-traits">the discussion on super traits below</a> for more detail.</p>
<p>These scope rules provide good ergonomics for associated types in
particular, and a consistent scope model for language constructs that
can contain items (like traits, impls, and modules). In the long run,
we should also explore imports for trait items, i.e. <code>use Trait::some_method</code>, but that is out of scope for this RFC.</p>
<p>Note that, according to this proposal, associated types/lifetimes are <em>not</em> in
scope for the optional <code>where</code> clause on the trait header. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;Input&gt;
    // type parameters in scope, but associated types are not:
    where Bar&lt;Input, Self::Output&gt;: Encodable {

    type Output;
    ...
}
#}</code></pre></pre>
<p>This setup seems more intuitive than allowing the trait header to refer directly
to items defined within the trait body.</p>
<p>It's also worth noting that <em>trait-level</em> <code>where</code> clauses are never needed for
constraining associated types anyway, because associated types also have <code>where</code>
clauses. Thus, the above example could (and should) instead be written as
follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;Input&gt; {
    type Output where Bar&lt;Input, Output&gt;: Encodable;
    ...
}
#}</code></pre></pre>
<a class="header" href="#constraining-associated-types" id="constraining-associated-types"><h2>Constraining associated types</h2></a>
<p>Associated types are not treated as parameters to a trait, but in some cases a
function will want to constrain associated types in some way. For example, as
explained in the Motivation section, the <code>Iterator</code> trait should treat the
element type as an output:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type A;
    fn next(&amp;mut self) -&gt; Option&lt;A&gt;;
    ...
}
#}</code></pre></pre>
<p>For code that works with iterators generically, there is no need to constrain
this type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn collect_into_vec&lt;I: Iterator&gt;(iter: I) -&gt; Vec&lt;I::A&gt; { ... }
#}</code></pre></pre>
<p>But other code may have requirements for the element type:</p>
<ul>
<li>That it implements some traits (bounds).</li>
<li>That it unifies with a particular type.</li>
</ul>
<p>These requirements can be imposed via <code>where</code> clauses:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn print_iter&lt;I&gt;(iter: I) where I: Iterator, I::A: Show { ... }
fn sum_uints&lt;I&gt;(iter: I) where I: Iterator, I::A = uint { ... }
#}</code></pre></pre>
<p>In addition, there is a shorthand for equality constraints:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sum_uints&lt;I: Iterator&lt;A = uint&gt;&gt;(iter: I) { ... }
#}</code></pre></pre>
<p>In general, a trait like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;Input1, Input2&gt; {
    type Output1;
    type Output2;
    lifetime 'a;
    const C: bool;
    ...
}
#}</code></pre></pre>
<p>can be written in a bound like:</p>
<pre><code>T: Foo&lt;I1, I2&gt;
T: Foo&lt;I1, I2, Output1 = O1&gt;
T: Foo&lt;I1, I2, Output2 = O2&gt;
T: Foo&lt;I1, I2, Output1 = O1, Output2 = O2&gt;
T: Foo&lt;I1, I2, Output1 = O1, 'a = 'b, Output2 = O2&gt;
T: Foo&lt;I1, I2, Output1 = O1, 'a = 'b, C = true, Output2 = O2&gt;
</code></pre>
<p>The output constraints must come after all input arguments, but can appear in
any order.</p>
<p>Note that output constraints are allowed when referencing a trait in a <em>type</em> or
a <em>bound</em>, but not in an <code>IMPL_SEGMENT</code> path:</p>
<ul>
<li>As a type: <code>fn foo(obj: Box&lt;Iterator&lt;A = uint&gt;&gt;</code> is allowed.</li>
<li>In a bound: <code>fn foo&lt;I: Iterator&lt;A = uint&gt;&gt;(iter: I)</code> is allowed.</li>
<li>In an <code>IMPL_SEGMENT</code>: <code>&lt;I as Iterator&lt;A = uint&gt;&gt;::next</code> is <em>not</em> allowed.</li>
</ul>
<p>The reason not to allow output constraints in <code>IMPL_SEGMENT</code> is that such paths
are references to a trait implementation that has already been determined -- it
does not make sense to apply additional constraints to the implementation when
referencing it.</p>
<p>Output constraints are a handy shorthand when using trait bounds, but they are a
<em>necessity</em> for trait objects, which we discuss next.</p>
<a class="header" href="#trait-objects" id="trait-objects"><h2>Trait objects</h2></a>
<p>When using trait objects, the <code>Self</code> type is &quot;erased&quot;, so different types
implementing the trait can be used under the same trait object type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Show for Foo { ... }
impl Show for Bar { ... }

fn make_vec() -&gt; Vec&lt;Box&lt;Show&gt;&gt; {
    let f = Foo { ... };
    let b = Bar { ... };
    let mut v = Vec::new();
    v.push(box f as Box&lt;Show&gt;);
    v.push(box b as Box&lt;Show&gt;);
    v
}
#}</code></pre></pre>
<p>One consequence of erasing <code>Self</code> is that methods using the <code>Self</code> type as
arguments or return values cannot be used on trait objects, since their types
would differ for different choices of <code>Self</code>.</p>
<p>In the model presented in this RFC, traits have additional input parameters
beyond <code>Self</code>, as well as associated types that may vary depending on all of the
input parameters. This raises the question: which of these types, if any, are
erased in trait objects?</p>
<p>The approach we take here is the simplest and most conservative: when using a
trait as a <em>type</em> (i.e., as a trait object), <em>all</em> input and output types must
be provided as part of the type. In other words, <em>only</em> the <code>Self</code> type is
erased, and all other types are specified statically in the trait object type.</p>
<p>Consider again the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;Input1, Input2&gt; {
    type Output1;
    type Output2;
    lifetime 'a;
    const C: bool;
    ...
}
#}</code></pre></pre>
<p>Unlike the case for static trait bounds, which do not have to specify any of the
associated types, lifetimes, or consts, (but do have to specify the input types),
trait object types must specify all of the types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn consume_foo&lt;T: Foo&lt;I1, I2&gt;&gt;(t: T) // this is valid
fn consume_obj(t: Box&lt;Foo&lt;I1, I2&gt;&gt;)  // this is NOT valid

// but this IS valid:
fn consume_obj(t: Box&lt;Foo&lt;I1, I2, Output1 = O2, Output2 = O2, 'a = 'static, C = true&gt;&gt;)
#}</code></pre></pre>
<p>With this design, it is clear that none of the non-<code>Self</code> types are erased as
part of trait objects. But it leaves wiggle room to relax this restriction
later on: trait object types that are not allowed under this design can be given
meaning in some later design.</p>
<a class="header" href="#inherent-associated-items" id="inherent-associated-items"><h2>Inherent associated items</h2></a>
<p>All associated items are also allowed in inherent <code>impl</code>s, so a definition like
the following is allowed:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyGraph { ... }
struct MyNode { ... }
struct MyEdge { ... }

impl MyGraph {
    type N = MyNode;
    type E = MyEdge;

    // Note: associated types in scope, just as with trait bodies
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool {
        ...
    }

    ...
}
#}</code></pre></pre>
<p>Inherent associated items are referenced similarly to trait associated items:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn distance(g: &amp;MyGraph, from: &amp;MyGraph::N, to: &amp;MyGraph::N) -&gt; uint { ... }
#}</code></pre></pre>
<p>Note, however, that output constraints do not make sense for inherent outputs:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// This is *not* a legal type:
MyGraph&lt;N = SomeNodeType&gt;
#}</code></pre></pre>
<a class="header" href="#the-inputoutput-type-distinction" id="the-inputoutput-type-distinction"><h2>The input/output type distinction</h2></a>
<p>When designing a trait that references some unknown type, you now have the
option of taking that type as an input parameter, or specifying it as an output
associated type. What are the ramifications of this decision?</p>
<a class="header" href="#coherence-implications" id="coherence-implications"><h3>Coherence implications</h3></a>
<p>Input types are used when determining which <code>impl</code> matches, even for the same
<code>Self</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterable1&lt;A&gt; {
    type I: Iterator&lt;A&gt;;
    fn iter(self) -&gt; I;
}

// These impls have distinct input types, so are allowed
impl Iterable1&lt;u8&gt; for Foo { ... }
impl Iterable1&lt;char&gt; for Foo { ... }

trait Iterable2 {
    type A;
    type I: Iterator&lt;A&gt;;
    fn iter(self) -&gt; I;
}

// These impls apply to a common input (Foo), so are NOT allowed
impl Iterable2 for Foo { ... }
impl Iterable2 for Foo { ... }
#}</code></pre></pre>
<p>More formally, the <em>coherence</em> property is revised as follows:</p>
<ul>
<li>Given a trait and values for all its type parameters (inputs, including
<code>Self</code>), there is at most one applicable <code>impl</code>.</li>
</ul>
<p>In the <a href="https://github.com/rust-lang/rfcs/pull/48">trait reform RFC</a>, coherence
is guaranteed by maintaining two other key properties, which are revised as
follows:</p>
<p><em>Orphan check</em>: Every implementation must meet one of
the following conditions:</p>
<ol>
<li>
<p>The trait being implemented (if any) must be defined in the current crate.</p>
</li>
<li>
<p>At least one of the input type parameters (including but not
necessarily <code>Self</code>) must meet the following grammar, where <code>C</code>
is a struct or enum defined within the current crate:</p>
<pre><code>T = C
  | [T]
  | [T, ..n]
  | &amp;T
  | &amp;mut T
  | ~T
  | (..., T, ...)
  | X&lt;..., T, ...&gt; where X is not bivariant with respect to T
</code></pre>
</li>
</ol>
<p><em>Overlapping instances</em>: No two implementations can be instantiable
with the same set of types for the input type parameters.</p>
<p>See the <a href="https://github.com/rust-lang/rfcs/pull/48">trait reform RFC</a> for more
discussion of these properties.</p>
<a class="header" href="#type-inference-implications" id="type-inference-implications"><h3>Type inference implications</h3></a>
<p>Finally, <em>output</em> type parameters can be inferred/resolved as soon as there is
a matching <code>impl</code> based on the input type parameters. Because of the
coherence property above, there can be at most one.</p>
<p>On the other hand, even if there is only one applicable <code>impl</code>, type inference
is <em>not</em> allowed to infer the input type parameters from it. This restriction
makes it possible to ensure <em>crate concatenation</em>: adding another crate may add
<code>impl</code>s for a given trait, and if type inference depended on the absence of such
<code>impl</code>s, importing a crate could break existing code.</p>
<p>In practice, these inference benefits can be quite valuable. For example, in the
<code>Add</code> trait given at the beginning of this RFC, the <code>Sum</code> output type is
immediately known once the input types are known, which can avoid the need for
type annotations.</p>
<a class="header" href="#limitations" id="limitations"><h2>Limitations</h2></a>
<p>The main limitation of associated items as presented here is about associated
<em>types</em> in particular. You might be tempted to write a trait like the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterable {
    type A;
    type I: Iterator&lt;&amp;'a A&gt;; // what is the lifetime here?
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; I;  // and how to connect it to self?
}
#}</code></pre></pre>
<p>The problem is that, when implementing this trait, the return type <code>I</code> of <code>iter</code>
must generally depend on the <em>lifetime</em> of self. For example, the corresponding
method in <code>Vec</code> looks like the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Vec&lt;T&gt; {
    fn iter(&amp;'a self) -&gt; Items&lt;'a, T&gt; { ... }
}
#}</code></pre></pre>
<p>This means that, given a <code>Vec&lt;T&gt;</code>, there isn't a <em>single</em> type <code>Items&lt;T&gt;</code> for
iteration -- rather, there is a <em>family</em> of types, one for each input lifetime.
In other words, the associated type <code>I</code> in the <code>Iterable</code> needs to be
&quot;higher-kinded&quot;: not just a single type, but rather a family:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterable {
    type A;
    type I&lt;'a&gt;: Iterator&lt;&amp;'a A&gt;;
    fn iter&lt;'a&gt;(&amp;self) -&gt; I&lt;'a&gt;;
}
#}</code></pre></pre>
<p>In this case, <code>I</code> is parameterized by a lifetime, but in other cases (like
<code>map</code>) an associated type needs to be parameterized by a type.</p>
<p>In general, such higher-kinded types (HKTs) are a much-requested feature for
Rust, and they would extend the reach of associated types. But the design and
implementation of higher-kinded types is, by itself, a significant investment.
The point of view of this RFC is that associated items bring the most important
changes needed to stabilize our existing traits (and add a few key others),
while HKTs will allow us to define important traits in the future but are not
necessary for 1.0.</p>
<a class="header" href="#encoding-higher-kinded-types" id="encoding-higher-kinded-types"><h3>Encoding higher-kinded types</h3></a>
<p>That said, it's worth pointing out that variants of higher-kinded types can be
encoded in the system being proposed here.</p>
<p>For example, the <code>Iterable</code> example above can be written in the following
somewhat contorted style:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait IterableOwned {
    type A;
    type I: Iterator&lt;A&gt;;
    fn iter_owned(self) -&gt; I;
}

trait Iterable {
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; &lt;&amp;'a Self&gt;::I where &amp;'a Self: IterableOwned {
        IterableOwned::iter_owned(self)
    }
}
#}</code></pre></pre>
<p>The idea here is to define a trait that takes, as input type/lifetimes
parameters, the parameters to any HKTs. In this case, the trait is implemented
on the type <code>&amp;'a Self</code>, which includes the lifetime parameter.</p>
<p>We can in fact generalize this technique to encode arbitrary HKTs:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// The kind * -&gt; *
trait TypeToType&lt;Input&gt; {
    type Output;
}
type Apply&lt;Name, Elt&gt; where Name: TypeToType&lt;Elt&gt; = Name::Output;

struct Vec_;
struct DList_;

impl&lt;T&gt; TypeToType&lt;T&gt; for Vec_ {
    type Output = Vec&lt;T&gt;;
}

impl&lt;T&gt; TypeToType&lt;T&gt; for DList_ {
    type Output = DList&lt;T&gt;;
}

trait Mappable
{
    type E;
    type HKT where Apply&lt;HKT, E&gt; = Self;

    fn map&lt;F&gt;(self, f: E -&gt; F) -&gt; Apply&lt;HKT, F&gt;;
}
#}</code></pre></pre>
<p>While the above demonstrates the versatility of associated types and <code>where</code>
clauses, it is probably too much of a hack to be viable for use in <code>libstd</code>.</p>
<a class="header" href="#associated-consts-in-generic-code" id="associated-consts-in-generic-code"><h3>Associated consts in generic code</h3></a>
<p>If the value of an associated const depends on a type parameter (including
<code>Self</code>), it cannot be used in a constant expression. This restriction will
almost certainly be lifted in the future, but this raises questions outside the
scope of this RFC.</p>
<a class="header" href="#staging" id="staging"><h1>Staging</h1></a>
<p>Associated lifetimes are probably not necessary for the 1.0 timeframe. While we
currently have a few traits that are parameterized by lifetimes, most of these
can go away once DST lands.</p>
<p>On the other hand, associated lifetimes are probably trivial to implement once
associated types have been implemented.</p>
<a class="header" href="#other-interactions" id="other-interactions"><h1>Other interactions</h1></a>
<a class="header" href="#interaction-with-implied-bounds" id="interaction-with-implied-bounds"><h2>Interaction with implied bounds</h2></a>
<p>As part of the
<a href="http://smallcultfollowing.com/babysteps/blog/2014/07/06/implied-bounds/">implied bounds</a>
idea, it may be desirable for this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn pick_node&lt;G&gt;(g: &amp;G) -&gt; &amp;&lt;G as Graph&gt;::N
#}</code></pre></pre>
<p>to be sugar for this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn pick_node&lt;G: Graph&gt;(g: &amp;G) -&gt; &amp;&lt;G as Graph&gt;::N
#}</code></pre></pre>
<p>But this feature can easily be added later, as part of a general implied bounds RFC.</p>
<a class="header" href="#future-proofing-specialization-of-impls" id="future-proofing-specialization-of-impls"><h2>Future-proofing: specialization of <code>impl</code>s</h2></a>
<p>In the future, we may wish to relax the &quot;overlapping instances&quot; rule so that one
can provide &quot;blanket&quot; trait implementations and then &quot;specialize&quot; them for
particular types. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Sliceable {
    type Slice;
    // note: not using &amp;self here to avoid need for HKT
    fn as_slice(self) -&gt; Slice;
}

impl&lt;'a, T&gt; Sliceable for &amp;'a T {
    type Slice = &amp;'a T;
    fn as_slice(self) -&gt; &amp;'a T { self }
}

impl&lt;'a, T&gt; Sliceable for &amp;'a Vec&lt;T&gt; {
    type Slice = &amp;'a [T];
    fn as_slice(self) -&gt; &amp;'a [T] { self.as_slice() }
}
#}</code></pre></pre>
<p>But then there's a difficult question:</p>
<pre><code>fn dice&lt;A&gt;(a: &amp;A) -&gt; &amp;A::Slice where &amp;A: Slicable {
    a // is this allowed?
}
</code></pre>
<p>Here, the blanket and specialized implementations provide incompatible
associated types. When working with the trait generically, what can we assume
about the associated type? If we assume it is the blanket one, the type may
change during monomorphization (when specialization takes effect)!</p>
<p>The RFC <em>does</em> allow generic code to &quot;see&quot; associated types provided by blanket
implementations, so this is a potential problem.</p>
<p>Our suggested strategy is the following. If at some later point we wish to add
specialization, traits would have to <em>opt in</em> explicitly. For such traits, we
would <em>not</em> allow generic code to &quot;see&quot; associated types for blanket
implementations; instead, output types would only be visible when all input
types were concretely known. This approach is backwards-compatible with the RFC,
and is probably a good idea in any case.</p>
<a class="header" href="#alternatives" id="alternatives"><h1>Alternatives</h1></a>
<a class="header" href="#multidispatch-through-tuple-types" id="multidispatch-through-tuple-types"><h2>Multidispatch through tuple types</h2></a>
<p>This RFC clarifies trait matching by making trait type parameters inputs to
matching, and associated types outputs.</p>
<p>A more radical alternative would be to <em>remove type parameters from traits</em>, and
instead support multiple input types through a separate multidispatch mechanism.</p>
<p>In this design, the <code>Add</code> trait would be written and implemented as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Lhs and Rhs are *inputs*
trait Add for (Lhs, Rhs) {
    type Sum; // Sum is an *output*
    fn add(&amp;Lhs, &amp;Rhs) -&gt; Sum;
}

impl Add for (int, int) {
    type Sum = int;
    fn add(left: &amp;int, right: &amp;int) -&gt; int { ... }
}

impl Add for (int, Complex) {
    type Sum = Complex;
    fn add(left: &amp;int, right: &amp;Complex) -&gt; Complex { ... }
}
#}</code></pre></pre>
<p>The <code>for</code> syntax in the trait definition is used for multidispatch traits, here
saying that <code>impl</code>s must be for pairs of types which are bound to <code>Lhs</code> and
<code>Rhs</code> respectively. The <code>add</code> function can then be invoked in UFCS style by
writing</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Add::add(some_int, some_complex)
#}</code></pre></pre>
<p><em>Advantages of the tuple approach</em>:</p>
<ul>
<li>
<p>It does not force a distinction between <code>Self</code> and other input types, which in
some cases (including binary operators like <code>Add</code>) can be artificial.</p>
</li>
<li>
<p>Makes it possible to specify input types without specifying the trait:
<code>&lt;(A, B)&gt;::Sum</code> rather than <code>&lt;A as Add&lt;B&gt;&gt;::Sum</code>.</p>
</li>
</ul>
<p><em>Disadvantages of the tuple approach</em>:</p>
<ul>
<li>
<p>It's more painful when you <em>do</em> want a method rather than a function.</p>
</li>
<li>
<p>Requires <code>where</code> clauses when used in bounds: <code>where (A, B): Trait</code> rather
than <code>A: Trait&lt;B&gt;</code>.</p>
</li>
<li>
<p>It gives two ways to write single dispatch: either without <code>for</code>, or using
<code>for</code> with a single-element tuple.</p>
</li>
<li>
<p>There's a somewhat jarring distinction between single/multiple dispatch
traits, making the latter feel &quot;bolted on&quot;.</p>
</li>
<li>
<p>The tuple syntax is unusual in acting as a binder of its types, as opposed to
the <code>Trait&lt;A, B&gt;</code> syntax.</p>
</li>
<li>
<p>Relatedly, the generics syntax for traits is immediately understandable (a
family of traits) based on other uses of generics in the language, while the
tuple notation stands alone.</p>
</li>
<li>
<p>Less clear story for trait objects (although the fact that <code>Self</code> is the only
erased input type in this RFC may seem somewhat arbitrary).</p>
</li>
</ul>
<p>On balance, the generics-based approach seems like a better fit for the language
design, especially in its interaction with methods and the object system.</p>
<a class="header" href="#a-backwards-compatible-version" id="a-backwards-compatible-version"><h2>A backwards-compatible version</h2></a>
<p>Yet another alternative would be to allow trait type parameters to be either
inputs or outputs, marking the inputs with a keyword <code>in</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;in Rhs, Sum&gt; {
    fn add(&amp;Lhs, &amp;Rhs) -&gt; Sum;
}
#}</code></pre></pre>
<p>This would provide a way of adding multidispatch now, and then adding associated
items later on without breakage. If, in addition, output types had to come after
all input types, it might even be possible to migrate output type parameters
like <code>Sum</code> above into associated types later.</p>
<p>This is perhaps a reasonable fallback, but it seems better to introduce a clean
design with both multidispatch and associated items together.</p>
<a class="header" href="#unresolved-questions" id="unresolved-questions"><h1>Unresolved questions</h1></a>
<a class="header" href="#super-traits" id="super-traits"><h2>Super traits</h2></a>
<p>This RFC largely ignores super traits.</p>
<p>Currently, the implementation of super traits treats them identically to a
<code>where</code> clause that bounds <code>Self</code>, and this RFC does not propose to change
that. However, a follow-up RFC should clarify that this is the intended
semantics for super traits.</p>
<p>Note that this treatment of super traits is, in particular, consistent with the
proposed scoping rules, which do not bring items from super traits into scope in
the body of a subtrait; they must be accessed via <code>Self::item_name</code>.</p>
<a class="header" href="#equality-constraints-in-where-clauses" id="equality-constraints-in-where-clauses"><h2>Equality constraints in <code>where</code> clauses</h2></a>
<p>This RFC allows equality constraints on types for associated types, but does not
propose a similar feature for <code>where</code> clauses. That will be the subject of a
follow-up RFC.</p>
<a class="header" href="#multiple-trait-object-bounds-for-the-same-trait" id="multiple-trait-object-bounds-for-the-same-trait"><h2>Multiple trait object bounds for the same trait</h2></a>
<p>The design here makes it possible to write bounds or trait objects that mention
the same trait, multiple times, with different inputs:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn mulit_add&lt;T: Add&lt;int&gt; + Add&lt;Complex&gt;&gt;(t: T) -&gt; T { ... }
fn mulit_add_obj(t: Box&lt;Add&lt;int&gt; + Add&lt;Complex&gt;&gt;) -&gt; Box&lt;Add&lt;int&gt; + Add&lt;Complex&gt;&gt; { ... }
#}</code></pre></pre>
<p>This seems like a potentially useful feature, and should be unproblematic for
bounds, but may have implications for vtables that make it problematic for trait
objects. Whether or not such trait combinations are allowed will likely depend
on implementation concerns, which are not yet clear.</p>
<a class="header" href="#generic-associated-consts-in-match-patterns" id="generic-associated-consts-in-match-patterns"><h2>Generic associated consts in match patterns</h2></a>
<p>It seems desirable to allow constants that depend on type parameters in match
patterns, but it's not clear how to do so while still checking exhaustiveness
and reachability of the match arms. Most likely this requires new forms of
where clause, to constrain associated constant values.</p>
<p>For now, we simply defer the question.</p>
<a class="header" href="#generic-associated-consts-in-array-sizes" id="generic-associated-consts-in-array-sizes"><h2>Generic associated consts in array sizes</h2></a>
<p>It would be useful to be able to use trait-associated constants in generic code.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Shouldn't this be OK?
const ALIAS_N: usize = &lt;T&gt;::N;
let x: [u8; &lt;T&gt;::N] = [0u8; ALIAS_N];
// Or...
let x: [u8; T::N + 1] = [0u8; T::N + 1];
#}</code></pre></pre>
<p>However, this causes some problems. What should we do with the following case in
type checking, where we need to prove that a generic is valid for any <code>T</code>?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: [u8; T::N + T::N] = [0u8; 2 * T::N];
#}</code></pre></pre>
<p>We would like to handle at least some obvious cases (e.g. proving that
<code>T::N == T::N</code>), but without trying to prove arbitrary statements about
arithmetic. The question of how to do this is deferred.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="0194-cfg-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="0198-slice-notation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="0194-cfg-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="0198-slice-notation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>1298-incremental-compilation - The Rust RFC Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="0001-private-fields.html">0001-private-fields</a></li><li><a href="0002-rfc-process.html">0002-rfc-process</a></li><li><a href="0003-attribute-usage.html">0003-attribute-usage</a></li><li><a href="0008-new-intrinsics.html">0008-new-intrinsics</a></li><li><a href="0016-more-attributes.html">0016-more-attributes</a></li><li><a href="0019-opt-in-builtin-traits.html">0019-opt-in-builtin-traits</a></li><li><a href="0026-remove-priv.html">0026-remove-priv</a></li><li><a href="0034-bounded-type-parameters.html">0034-bounded-type-parameters</a></li><li><a href="0040-libstd-facade.html">0040-libstd-facade</a></li><li><a href="0042-regexps.html">0042-regexps</a></li><li><a href="0048-traits.html">0048-traits</a></li><li><a href="0049-match-arm-attributes.html">0049-match-arm-attributes</a></li><li><a href="0050-assert.html">0050-assert</a></li><li><a href="0059-remove-tilde.html">0059-remove-tilde</a></li><li><a href="0060-rename-strbuf.html">0060-rename-strbuf</a></li><li><a href="0063-module-file-system-hierarchy.html">0063-module-file-system-hierarchy</a></li><li><a href="0066-better-temporary-lifetimes.html">0066-better-temporary-lifetimes</a></li><li><a href="0068-const-unsafe-pointers.html">0068-const-unsafe-pointers</a></li><li><a href="0069-ascii-literals.html">0069-ascii-literals</a></li><li><a href="0071-const-block-expr.html">0071-const-block-expr</a></li><li><a href="0079-undefined-struct-layout.html">0079-undefined-struct-layout</a></li><li><a href="0085-pattern-macros.html">0085-pattern-macros</a></li><li><a href="0086-plugin-registrar.html">0086-plugin-registrar</a></li><li><a href="0087-trait-bounds-with-plus.html">0087-trait-bounds-with-plus</a></li><li><a href="0089-loadable-lints.html">0089-loadable-lints</a></li><li><a href="0090-lexical-syntax-simplification.html">0090-lexical-syntax-simplification</a></li><li><a href="0092-struct-grammar.html">0092-struct-grammar</a></li><li><a href="0093-remove-format-intl.html">0093-remove-format-intl</a></li><li><a href="0100-partial-cmp.html">0100-partial-cmp</a></li><li><a href="0107-pattern-guards-with-bind-by-move.html">0107-pattern-guards-with-bind-by-move</a></li><li><a href="0109-remove-crate-id.html">0109-remove-crate-id</a></li><li><a href="0111-index-traits.html">0111-index-traits</a></li><li><a href="0112-remove-cross-borrowing.html">0112-remove-cross-borrowing</a></li><li><a href="0114-closures.html">0114-closures</a></li><li><a href="0115-rm-integer-fallback.html">0115-rm-integer-fallback</a></li><li><a href="0116-no-module-shadowing.html">0116-no-module-shadowing</a></li><li><a href="0123-share-to-threadsafe.html">0123-share-to-threadsafe</a></li><li><a href="0130-box-not-special.html">0130-box-not-special</a></li><li><a href="0131-target-specification.html">0131-target-specification</a></li><li><a href="0132-ufcs.html">0132-ufcs</a></li><li><a href="0135-where.html">0135-where</a></li><li><a href="0136-no-privates-in-public.html">0136-no-privates-in-public</a></li><li><a href="0139-remove-cross-borrowing-entirely.html">0139-remove-cross-borrowing-entirely</a></li><li><a href="0141-lifetime-elision.html">0141-lifetime-elision</a></li><li><a href="0151-capture-by-value.html">0151-capture-by-value</a></li><li><a href="0155-anonymous-impl-only-in-same-module.html">0155-anonymous-impl-only-in-same-module</a></li><li><a href="0160-if-let.html">0160-if-let</a></li><li><a href="0164-feature-gate-slice-pats.html">0164-feature-gate-slice-pats</a></li><li><a href="0168-mod.html">0168-mod</a></li><li><a href="0169-use-path-as-id.html">0169-use-path-as-id</a></li><li><a href="0179-and-mut-patterns.html">0179-and-mut-patterns</a></li><li><a href="0184-tuple-accessors.html">0184-tuple-accessors</a></li><li><a href="0192-bounds-on-object-and-generic-types.html">0192-bounds-on-object-and-generic-types</a></li><li><a href="0194-cfg-syntax.html">0194-cfg-syntax</a></li><li><a href="0195-associated-items.html">0195-associated-items</a></li><li><a href="0198-slice-notation.html">0198-slice-notation</a></li><li><a href="0199-ownership-variants.html">0199-ownership-variants</a></li><li><a href="0201-error-chaining.html">0201-error-chaining</a></li><li><a href="0202-subslice-syntax-change.html">0202-subslice-syntax-change</a></li><li><a href="0212-restore-int-fallback.html">0212-restore-int-fallback</a></li><li><a href="0213-defaulted-type-params.html">0213-defaulted-type-params</a></li><li><a href="0214-while-let.html">0214-while-let</a></li><li><a href="0216-collection-views.html">0216-collection-views</a></li><li><a href="0218-empty-struct-with-braces.html">0218-empty-struct-with-braces</a></li><li><a href="0221-panic.html">0221-panic</a></li><li><a href="0230-remove-runtime.html">0230-remove-runtime</a></li><li><a href="0231-upvar-capture-inference.html">0231-upvar-capture-inference</a></li><li><a href="0234-variants-namespace.html">0234-variants-namespace</a></li><li><a href="0235-collections-conventions.html">0235-collections-conventions</a></li><li><a href="0236-error-conventions.html">0236-error-conventions</a></li><li><a href="0240-unsafe-api-location.html">0240-unsafe-api-location</a></li><li><a href="0241-deref-conversions.html">0241-deref-conversions</a></li><li><a href="0243-trait-based-exception-handling.html">0243-trait-based-exception-handling</a></li><li><a href="0246-const-vs-static.html">0246-const-vs-static</a></li><li><a href="0255-object-safety.html">0255-object-safety</a></li><li><a href="0256-remove-refcounting-gc-of-t.html">0256-remove-refcounting-gc-of-t</a></li><li><a href="0320-nonzeroing-dynamic-drop.html">0320-nonzeroing-dynamic-drop</a></li><li><a href="0326-restrict-xXX-to-ascii.html">0326-restrict-xXX-to-ascii</a></li><li><a href="0339-statically-sized-literals.html">0339-statically-sized-literals</a></li><li><a href="0341-remove-virtual-structs.html">0341-remove-virtual-structs</a></li><li><a href="0342-keywords.html">0342-keywords</a></li><li><a href="0344-conventions-galore.html">0344-conventions-galore</a></li><li><a href="0356-no-module-prefixes.html">0356-no-module-prefixes</a></li><li><a href="0369-num-reform.html">0369-num-reform</a></li><li><a href="0378-expr-macros.html">0378-expr-macros</a></li><li><a href="0379-remove-reflection.html">0379-remove-reflection</a></li><li><a href="0380-stabilize-std-fmt.html">0380-stabilize-std-fmt</a></li><li><a href="0385-module-system-cleanup.html">0385-module-system-cleanup</a></li><li><a href="0387-higher-ranked-trait-bounds.html">0387-higher-ranked-trait-bounds</a></li><li><a href="0390-enum-namespacing.html">0390-enum-namespacing</a></li><li><a href="0401-coercions.html">0401-coercions</a></li><li><a href="0403-cargo-build-command.html">0403-cargo-build-command</a></li><li><a href="0404-change-prefer-dynamic.html">0404-change-prefer-dynamic</a></li><li><a href="0418-struct-variants.html">0418-struct-variants</a></li><li><a href="0430-finalizing-naming-conventions.html">0430-finalizing-naming-conventions</a></li><li><a href="0438-precedence-of-plus.html">0438-precedence-of-plus</a></li><li><a href="0439-cmp-ops-reform.html">0439-cmp-ops-reform</a></li><li><a href="0445-extension-trait-conventions.html">0445-extension-trait-conventions</a></li><li><a href="0446-es6-unicode-escapes.html">0446-es6-unicode-escapes</a></li><li><a href="0447-no-unused-impl-parameters.html">0447-no-unused-impl-parameters</a></li><li><a href="0450-un-feature-gate-some-more-gates.html">0450-un-feature-gate-some-more-gates</a></li><li><a href="0453-macro-reform.html">0453-macro-reform</a></li><li><a href="0458-send-improvements.html">0458-send-improvements</a></li><li><a href="0459-disallow-shadowing.html">0459-disallow-shadowing</a></li><li><a href="0461-tls-overhaul.html">0461-tls-overhaul</a></li><li><a href="0463-future-proof-literal-suffixes.html">0463-future-proof-literal-suffixes</a></li><li><a href="0469-feature-gate-box-patterns.html">0469-feature-gate-box-patterns</a></li><li><a href="0474-path-reform.html">0474-path-reform</a></li><li><a href="0486-std-ascii-reform.html">0486-std-ascii-reform</a></li><li><a href="0490-dst-syntax.html">0490-dst-syntax</a></li><li><a href="0494-c_str-and-c_vec-stability.html">0494-c_str-and-c_vec-stability</a></li><li><a href="0495-array-pattern-changes.html">0495-array-pattern-changes</a></li><li><a href="0501-consistent_no_prelude_attributes.html">0501-consistent_no_prelude_attributes</a></li><li><a href="0503-prelude-stabilization.html">0503-prelude-stabilization</a></li><li><a href="0504-show-stabilization.html">0504-show-stabilization</a></li><li><a href="0505-api-comment-conventions.html">0505-api-comment-conventions</a></li><li><a href="0507-release-channels.html">0507-release-channels</a></li><li><a href="0509-collections-reform-part-2.html">0509-collections-reform-part-2</a></li><li><a href="0517-io-os-reform.html">0517-io-os-reform</a></li><li><a href="0520-new-array-repeat-syntax.html">0520-new-array-repeat-syntax</a></li><li><a href="0522-self-impl.html">0522-self-impl</a></li><li><a href="0526-fmt-text-writer.html">0526-fmt-text-writer</a></li><li><a href="0528-string-patterns.html">0528-string-patterns</a></li><li><a href="0529-conversion-traits.html">0529-conversion-traits</a></li><li><a href="0531-define-rfc-scope.html">0531-define-rfc-scope</a></li><li><a href="0532-self-in-use.html">0532-self-in-use</a></li><li><a href="0533-no-array-elem-moves.html">0533-no-array-elem-moves</a></li><li><a href="0534-deriving2derive.html">0534-deriving2derive</a></li><li><a href="0544-rename-int-uint.html">0544-rename-int-uint</a></li><li><a href="0546-Self-not-sized-by-default.html">0546-Self-not-sized-by-default</a></li><li><a href="0550-macro-future-proofing.html">0550-macro-future-proofing</a></li><li><a href="0556-raw-lifetime.html">0556-raw-lifetime</a></li><li><a href="0558-require-parentheses-for-chained-comparisons.html">0558-require-parentheses-for-chained-comparisons</a></li><li><a href="0560-integer-overflow.html">0560-integer-overflow</a></li><li><a href="0563-remove-ndebug.html">0563-remove-ndebug</a></li><li><a href="0565-show-string-guidelines.html">0565-show-string-guidelines</a></li><li><a href="0572-rustc-attribute.html">0572-rustc-attribute</a></li><li><a href="0574-drain-range.html">0574-drain-range</a></li><li><a href="0580-rename-collections.html">0580-rename-collections</a></li><li><a href="0587-fn-return-should-be-an-associated-type.html">0587-fn-return-should-be-an-associated-type</a></li><li><a href="0592-c-str-deref.html">0592-c-str-deref</a></li><li><a href="0593-forbid-Self-definitions.html">0593-forbid-Self-definitions</a></li><li><a href="0599-default-object-bound.html">0599-default-object-bound</a></li><li><a href="0601-replace-be-with-become.html">0601-replace-be-with-become</a></li><li><a href="0639-discriminant-intrinsic.html">0639-discriminant-intrinsic</a></li><li><a href="0640-debug-improvements.html">0640-debug-improvements</a></li><li><a href="0702-rangefull-expression.html">0702-rangefull-expression</a></li><li><a href="0735-allow-inherent-impls-anywhere.html">0735-allow-inherent-impls-anywhere</a></li><li><a href="0736-privacy-respecting-fru.html">0736-privacy-respecting-fru</a></li><li><a href="0738-variance.html">0738-variance</a></li><li><a href="0769-sound-generic-drop.html">0769-sound-generic-drop</a></li><li><a href="0771-std-iter-once.html">0771-std-iter-once</a></li><li><a href="0803-type-ascription.html">0803-type-ascription</a></li><li><a href="0809-box-and-in-for-stdlib.html">0809-box-and-in-for-stdlib</a></li><li><a href="0823-hash-simplification.html">0823-hash-simplification</a></li><li><a href="0832-from-elem-with-love.html">0832-from-elem-with-love</a></li><li><a href="0839-embrace-extend-extinguish.html">0839-embrace-extend-extinguish</a></li><li><a href="0840-no-panic-in-c-string.html">0840-no-panic-in-c-string</a></li><li><a href="0873-type-macros.html">0873-type-macros</a></li><li><a href="0879-small-base-lexing.html">0879-small-base-lexing</a></li><li><a href="0888-compiler-fence-intrinsics.html">0888-compiler-fence-intrinsics</a></li><li><a href="0909-move-thread-local-to-std-thread.html">0909-move-thread-local-to-std-thread</a></li><li><a href="0911-const-fn.html">0911-const-fn</a></li><li><a href="0921-entry_v3.html">0921-entry_v3</a></li><li><a href="0940-hyphens-considered-harmful.html">0940-hyphens-considered-harmful</a></li><li><a href="0953-op-assign.html">0953-op-assign</a></li><li><a href="0968-closure-return-type-syntax.html">0968-closure-return-type-syntax</a></li><li><a href="0979-align-splitn-with-other-languages.html">0979-align-splitn-with-other-languages</a></li><li><a href="0980-read-exact.html">0980-read-exact</a></li><li><a href="0982-dst-coercion.html">0982-dst-coercion</a></li><li><a href="1011-process.exit.html">1011-process.exit</a></li><li><a href="1014-stdout-existential-crisis.html">1014-stdout-existential-crisis</a></li><li><a href="1023-rebalancing-coherence.html">1023-rebalancing-coherence</a></li><li><a href="1030-prelude-additions.html">1030-prelude-additions</a></li><li><a href="1040-duration-reform.html">1040-duration-reform</a></li><li><a href="1044-io-fs-2.1.html">1044-io-fs-2.1</a></li><li><a href="1047-socket-timeouts.html">1047-socket-timeouts</a></li><li><a href="1048-rename-soft-link-to-symlink.html">1048-rename-soft-link-to-symlink</a></li><li><a href="1054-str-words.html">1054-str-words</a></li><li><a href="1057-io-error-sync.html">1057-io-error-sync</a></li><li><a href="1058-slice-tail-redesign.html">1058-slice-tail-redesign</a></li><li><a href="1066-safe-mem-forget.html">1066-safe-mem-forget</a></li><li><a href="1068-rust-governance.html">1068-rust-governance</a></li><li><a href="1096-remove-static-assert.html">1096-remove-static-assert</a></li><li><a href="1102-rename-connect-to-join.html">1102-rename-connect-to-join</a></li><li><a href="1105-api-evolution.html">1105-api-evolution</a></li><li><a href="1119-result-expect.html">1119-result-expect</a></li><li><a href="1122-language-semver.html">1122-language-semver</a></li><li><a href="1123-str-split-at.html">1123-str-split-at</a></li><li><a href="1131-likely-intrinsic.html">1131-likely-intrinsic</a></li><li><a href="1135-raw-pointer-comparisons.html">1135-raw-pointer-comparisons</a></li><li><a href="1152-slice-string-symmetry.html">1152-slice-string-symmetry</a></li><li><a href="1156-adjust-default-object-bounds.html">1156-adjust-default-object-bounds</a></li><li><a href="1174-into-raw-fd-socket-handle-traits.html">1174-into-raw-fd-socket-handle-traits</a></li><li><a href="1183-swap-out-jemalloc.html">1183-swap-out-jemalloc</a></li><li><a href="1184-stabilize-no_std.html">1184-stabilize-no_std</a></li><li><a href="1191-hir.html">1191-hir</a></li><li><a href="1192-inclusive-ranges.html">1192-inclusive-ranges</a></li><li><a href="1193-cap-lints.html">1193-cap-lints</a></li><li><a href="1194-set-recovery.html">1194-set-recovery</a></li><li><a href="1199-simd-infrastructure.html">1199-simd-infrastructure</a></li><li><a href="1200-cargo-install.html">1200-cargo-install</a></li><li><a href="1201-naked-fns.html">1201-naked-fns</a></li><li><a href="1210-impl-specialization.html">1210-impl-specialization</a></li><li><a href="1211-mir.html">1211-mir</a></li><li><a href="1212-line-endings.html">1212-line-endings</a></li><li><a href="1214-projections-lifetimes-and-wf.html">1214-projections-lifetimes-and-wf</a></li><li><a href="1216-bang-type.html">1216-bang-type</a></li><li><a href="1219-use-group-as.html">1219-use-group-as</a></li><li><a href="1228-placement-left-arrow.html">1228-placement-left-arrow</a></li><li><a href="1229-compile-time-asserts.html">1229-compile-time-asserts</a></li><li><a href="1236-stabilize-catch-panic.html">1236-stabilize-catch-panic</a></li><li><a href="1238-nonparametric-dropck.html">1238-nonparametric-dropck</a></li><li><a href="1240-repr-packed-unsafe-ref.html">1240-repr-packed-unsafe-ref</a></li><li><a href="1241-no-wildcard-deps.html">1241-no-wildcard-deps</a></li><li><a href="1242-rust-lang-crates.html">1242-rust-lang-crates</a></li><li><a href="1252-open-options.html">1252-open-options</a></li><li><a href="1257-drain-range-2.html">1257-drain-range-2</a></li><li><a href="1260-main-reexport.html">1260-main-reexport</a></li><li><a href="1268-allow-overlapping-impls-on-marker-traits.html">1268-allow-overlapping-impls-on-marker-traits</a></li><li><a href="1270-deprecation.html">1270-deprecation</a></li><li><a href="1288-time-improvements.html">1288-time-improvements</a></li><li><a href="1291-promote-libc.html">1291-promote-libc</a></li><li><a href="1298-incremental-compilation.html" class="active">1298-incremental-compilation</a></li><li><a href="1300-intrinsic-semantics.html">1300-intrinsic-semantics</a></li><li><a href="1307-osstring-methods.html">1307-osstring-methods</a></li><li><a href="1317-ide.html">1317-ide</a></li><li><a href="1327-dropck-param-eyepatch.html">1327-dropck-param-eyepatch</a></li><li><a href="1328-global-panic-handler.html">1328-global-panic-handler</a></li><li><a href="1331-grammar-is-canonical.html">1331-grammar-is-canonical</a></li><li><a href="1358-repr-align.html">1358-repr-align</a></li><li><a href="1359-process-ext-unix.html">1359-process-ext-unix</a></li><li><a href="1361-cargo-cfg-dependencies.html">1361-cargo-cfg-dependencies</a></li><li><a href="1398-kinds-of-allocators.html">1398-kinds-of-allocators</a></li><li><a href="1399-repr-pack.html">1399-repr-pack</a></li><li><a href="1414-rvalue_static_promotion.html">1414-rvalue_static_promotion</a></li><li><a href="1415-trim-std-os.html">1415-trim-std-os</a></li><li><a href="1419-slice-copy.html">1419-slice-copy</a></li><li><a href="1422-pub-restricted.html">1422-pub-restricted</a></li><li><a href="1432-replace-slice.html">1432-replace-slice</a></li><li><a href="1434-contains-method-for-ranges.html">1434-contains-method-for-ranges</a></li><li><a href="1440-drop-types-in-const.html">1440-drop-types-in-const</a></li><li><a href="1443-extended-compare-and-swap.html">1443-extended-compare-and-swap</a></li><li><a href="1444-union.html">1444-union</a></li><li><a href="1445-restrict-constants-in-patterns.html">1445-restrict-constants-in-patterns</a></li><li><a href="1461-net2-mutators.html">1461-net2-mutators</a></li><li><a href="1467-volatile.html">1467-volatile</a></li><li><a href="1479-unix-socket.html">1479-unix-socket</a></li><li><a href="1492-dotdot-in-patterns.html">1492-dotdot-in-patterns</a></li><li><a href="1498-ipv6addr-octets.html">1498-ipv6addr-octets</a></li><li><a href="1504-int128.html">1504-int128</a></li><li><a href="1506-adt-kinds.html">1506-adt-kinds</a></li><li><a href="1510-cdylib.html">1510-cdylib</a></li><li><a href="1513-less-unwinding.html">1513-less-unwinding</a></li><li><a href="1521-copy-clone-semantics.html">1521-copy-clone-semantics</a></li><li><a href="1522-conservative-impl-trait.html">1522-conservative-impl-trait</a></li><li><a href="1525-cargo-workspace.html">1525-cargo-workspace</a></li><li><a href="1535-stable-overflow-checks.html">1535-stable-overflow-checks</a></li><li><a href="1542-try-from.html">1542-try-from</a></li><li><a href="1543-integer_atomics.html">1543-integer_atomics</a></li><li><a href="1548-global-asm.html">1548-global-asm</a></li><li><a href="1552-contains-method-for-various-collections.html">1552-contains-method-for-various-collections</a></li><li><a href="1558-closure-to-fn-coercion.html">1558-closure-to-fn-coercion</a></li><li><a href="1559-attributes-with-literals.html">1559-attributes-with-literals</a></li><li><a href="1560-name-resolution.html">1560-name-resolution</a></li><li><a href="1561-macro-naming.html">1561-macro-naming</a></li><li><a href="1566-proc-macros.html">1566-proc-macros</a></li><li><a href="1567-long-error-codes-explanation-normalization.html">1567-long-error-codes-explanation-normalization</a></li><li><a href="1574-more-api-documentation-conventions.html">1574-more-api-documentation-conventions</a></li><li><a href="1576-macros-literal-matcher.html">1576-macros-literal-matcher</a></li><li><a href="1581-fused-iterator.html">1581-fused-iterator</a></li><li><a href="1584-macros.html">1584-macros</a></li><li><a href="1589-rustc-bug-fix-procedure.html">1589-rustc-bug-fix-procedure</a></li><li><a href="1590-macro-lifetimes.html">1590-macro-lifetimes</a></li><li><a href="1598-generic_associated_types.html">1598-generic_associated_types</a></li><li><a href="1607-style-rfcs.html">1607-style-rfcs</a></li><li><a href="1618-ergonomic-format-args.html">1618-ergonomic-format-args</a></li><li><a href="1620-regex-1.0.html">1620-regex-1.0</a></li><li><a href="1623-static.html">1623-static</a></li><li><a href="1624-loop-break-value.html">1624-loop-break-value</a></li><li><a href="1636-document_all_features.html">1636-document_all_features</a></li><li><a href="1640-duration-checked-sub.html">1640-duration-checked-sub</a></li><li><a href="1643-memory-model-strike-team.html">1643-memory-model-strike-team</a></li><li><a href="1644-default-and-expanded-rustc-errors.html">1644-default-and-expanded-rustc-errors</a></li><li><a href="1647-allow-self-in-where-clauses.html">1647-allow-self-in-where-clauses</a></li><li><a href="1649-atomic-access.html">1649-atomic-access</a></li><li><a href="1651-movecell.html">1651-movecell</a></li><li><a href="1653-assert_ne.html">1653-assert_ne</a></li><li><a href="1660-try-borrow.html">1660-try-borrow</a></li><li><a href="1665-windows-subsystem.html">1665-windows-subsystem</a></li><li><a href="1679-panic-safe-slicing.html">1679-panic-safe-slicing</a></li><li><a href="1681-macros-1.1.html">1681-macros-1.1</a></li><li><a href="1682-field-init-shorthand.html">1682-field-init-shorthand</a></li><li><a href="1683-docs-team.html">1683-docs-team</a></li><li><a href="1685-deprecate-anonymous-parameters.html">1685-deprecate-anonymous-parameters</a></li><li><a href="1695-add-error-macro.html">1695-add-error-macro</a></li><li><a href="1696-discriminant.html">1696-discriminant</a></li><li><a href="1717-dllimport.html">1717-dllimport</a></li><li><a href="1721-crt-static.html">1721-crt-static</a></li><li><a href="1725-unaligned-access.html">1725-unaligned-access</a></li><li><a href="1728-north-star.html">1728-north-star</a></li><li><a href="1733-trait-alias.html">1733-trait-alias</a></li><li><a href="1758-repr-transparent.html">1758-repr-transparent</a></li><li><a href="1774-roadmap-2017.html">1774-roadmap-2017</a></li><li><a href="1789-as-cell.html">1789-as-cell</a></li><li><a href="1824-crates.io-default-ranking.html">1824-crates.io-default-ranking</a></li><li><a href="1826-change-doc-default-urls.html">1826-change-doc-default-urls</a></li><li><a href="1828-rust-bookshelf.html">1828-rust-bookshelf</a></li><li><a href="1845-shared-from-slice.html">1845-shared-from-slice</a></li><li><a href="1849-non-static-type-id.html">1849-non-static-type-id</a></li><li><a href="1857-stabilize-drop-order.html">1857-stabilize-drop-order</a></li><li><a href="1859-try-trait.html">1859-try-trait</a></li><li><a href="1860-manually-drop.html">1860-manually-drop</a></li><li><a href="1861-extern-types.html">1861-extern-types</a></li><li><a href="1866-more-readable-assert-eq.html">1866-more-readable-assert-eq</a></li><li><a href="1868-portability-lint.html">1868-portability-lint</a></li><li><a href="1869-eprintln.html">1869-eprintln</a></li><li><a href="1884-unstable-sort.html">1884-unstable-sort</a></li><li><a href="1892-uninitialized-uninhabited.html">1892-uninitialized-uninhabited</a></li><li><a href="1909-unsized-rvalues.html">1909-unsized-rvalues</a></li><li><a href="1925-optional-match-vert.html">1925-optional-match-vert</a></li><li><a href="1937-ques-in-main.html">1937-ques-in-main</a></li><li><a href="1940-must-use-functions.html">1940-must-use-functions</a></li><li><a href="1946-intra-rustdoc-links.html">1946-intra-rustdoc-links</a></li><li><a href="1951-expand-impl-trait.html">1951-expand-impl-trait</a></li><li><a href="1961-clamp.html">1961-clamp</a></li><li><a href="1966-unsafe-pointer-reform.html">1966-unsafe-pointer-reform</a></li><li><a href="1969-cargo-prepublish.html">1969-cargo-prepublish</a></li><li><a href="1974-global-allocators.html">1974-global-allocators</a></li><li><a href="1977-public-private-dependencies.html">1977-public-private-dependencies</a></li><li><a href="1983-nursery-deprecation.html">1983-nursery-deprecation</a></li><li><a href="1985-tiered-browser-support.html">1985-tiered-browser-support</a></li><li><a href="1990-external-doc-attribute.html">1990-external-doc-attribute</a></li><li><a href="2000-const-generics.html">2000-const-generics</a></li><li><a href="2005-match-ergonomics.html">2005-match-ergonomics</a></li><li><a href="2008-non-exhaustive.html">2008-non-exhaustive</a></li><li><a href="2011-generic-assert.html">2011-generic-assert</a></li><li><a href="2025-nested-method-calls.html">2025-nested-method-calls</a></li><li><a href="2027-object_safe_for_dispatch.html">2027-object_safe_for_dispatch</a></li><li><a href="2033-experimental-coroutines.html">2033-experimental-coroutines</a></li><li><a href="2043-is-aligned-intrinsic.html">2043-is-aligned-intrinsic</a></li><li><a href="2044-license-rfcs.html">2044-license-rfcs</a></li><li><a href="2045-target-feature.html">2045-target-feature</a></li><li><a href="2046-label-break-value.html">2046-label-break-value</a></li><li><a href="2052-epochs.html">2052-epochs</a></li><li><a href="2056-allow-trivial-where-clause-constraints.html">2056-allow-trivial-where-clause-constraints</a></li><li><a href="2057-refcell-replace.html">2057-refcell-replace</a></li><li><a href="2070-panic-implementation.html">2070-panic-implementation</a></li><li><a href="2071-impl-trait-existential-types.html">2071-impl-trait-existential-types</a></li><li><a href="2071-impl-trait-type-alias.html">2071-impl-trait-type-alias</a></li><li><a href="2086-allow-if-let-irrefutables.html">2086-allow-if-let-irrefutables</a></li><li><a href="2089-implied-bounds.html">2089-implied-bounds</a></li><li><a href="2091-inline-semantic.html">2091-inline-semantic</a></li><li><a href="2093-infer-outlives.html">2093-infer-outlives</a></li><li><a href="2094-nll.html">2094-nll</a></li><li><a href="2102-unnamed-fields.html">2102-unnamed-fields</a></li><li><a href="2103-tool-attributes.html">2103-tool-attributes</a></li><li><a href="2113-dyn-trait-syntax.html">2113-dyn-trait-syntax</a></li><li><a href="2115-argument-lifetimes.html">2115-argument-lifetimes</a></li><li><a href="2116-alloc-me-maybe.html">2116-alloc-me-maybe</a></li><li><a href="2124-option-filter.html">2124-option-filter</a></li><li><a href="2126-path-clarity.html">2126-path-clarity</a></li><li><a href="2128-use-nested-groups.html">2128-use-nested-groups</a></li><li><a href="2132-copy-closures.html">2132-copy-closures</a></li><li><a href="2133-all-the-clones.html">2133-all-the-clones</a></li><li><a href="2136-build-systems.html">2136-build-systems</a></li><li><a href="2137-variadic.html">2137-variadic</a></li><li><a href="2141-alternative-registries.html">2141-alternative-registries</a></li><li><a href="2145-type-privacy.html">2145-type-privacy</a></li><li><a href="2151-raw-identifiers.html">2151-raw-identifiers</a></li><li><a href="2166-impl-only-use.html">2166-impl-only-use</a></li><li><a href="2169-euclidean-modulo.html">2169-euclidean-modulo</a></li><li><a href="2175-if-while-or-patterns.html">2175-if-while-or-patterns</a></li><li><a href="2195-really-tagged-unions.html">2195-really-tagged-unions</a></li><li><a href="2196-metabuild.html">2196-metabuild</a></li><li><a href="2203-const-repeat-expr.html">2203-const-repeat-expr</a></li><li><a href="2226-fmt-debug-hex.html">2226-fmt-debug-hex</a></li><li><a href="2229-capture-disjoint-fields.html">2229-capture-disjoint-fields</a></li><li><a href="2230-bury-description.html">2230-bury-description</a></li><li><a href="2235-libc-struct-traits.html">2235-libc-struct-traits</a></li><li><a href="2250-finalize-impl-dyn-syntax.html">2250-finalize-impl-dyn-syntax</a></li><li><a href="2282-profile-dependencies.html">2282-profile-dependencies</a></li><li><a href="2289-associated-type-bounds.html">2289-associated-type-bounds</a></li><li><a href="2294-if-let-guard.html">2294-if-let-guard</a></li><li><a href="2295-os-str-pattern.html">2295-os-str-pattern</a></li><li><a href="2296-option-replace.html">2296-option-replace</a></li><li><a href="2298-macro-at-most-once-rep.html">2298-macro-at-most-once-rep</a></li><li><a href="2300-self-in-typedefs.html">2300-self-in-typedefs</a></li><li><a href="2302-tuple-struct-self-ctor.html">2302-tuple-struct-self-ctor</a></li><li><a href="2306-convert-id.html">2306-convert-id</a></li><li><a href="2307-concrete-nonzero-types.html">2307-concrete-nonzero-types</a></li><li><a href="2314-roadmap-2018.html">2314-roadmap-2018</a></li><li><a href="2318-custom-test-frameworks.html">2318-custom-test-frameworks</a></li><li><a href="2325-stable-simd.html">2325-stable-simd</a></li><li><a href="2333-prior-art.html">2333-prior-art</a></li><li><a href="2338-type-alias-enum-variants.html">2338-type-alias-enum-variants</a></li><li><a href="2341-const-locals.html">2341-const-locals</a></li><li><a href="2342-const-control-flow.html">2342-const-control-flow</a></li><li><a href="2344-const-looping.html">2344-const-looping</a></li><li><a href="2345-const-panic.html">2345-const-panic</a></li><li><a href="2349-pin.html">2349-pin</a></li><li><a href="2351-is-sorted.html">2351-is-sorted</a></li><li><a href="2359-subslice-pattern-syntax.html">2359-subslice-pattern-syntax</a></li><li><a href="2360-bench-black-box.html">2360-bench-black-box</a></li><li><a href="2361-dbg-macro.html">2361-dbg-macro</a></li><li><a href="2363-arbitrary-enum-discriminant.html">2363-arbitrary-enum-discriminant</a></li><li><a href="2383-lint-reasons.html">2383-lint-reasons</a></li><li><a href="2386-used.html">2386-used</a></li><li><a href="2388-try-expr.html">2388-try-expr</a></li><li><a href="2394-async_await.html">2394-async_await</a></li><li><a href="2397-do-not-recommend.html">2397-do-not-recommend</a></li><li><a href="2412-optimize-attr.html">2412-optimize-attr</a></li><li><a href="2420-unreserve-proc.html">2420-unreserve-proc</a></li><li><a href="2421-unreservations-2018.html">2421-unreservations-2018</a></li><li><a href="2436-style-guide.html">2436-style-guide</a></li><li><a href="2437-rustfmt-stability.html">2437-rustfmt-stability</a></li><li><a href="2438-deny-integer-literal-overflow-lint.html">2438-deny-integer-literal-overflow-lint</a></li><li><a href="2451-re-rebalancing-coherence.html">2451-re-rebalancing-coherence</a></li><li><a href="2457-non-ascii-idents.html">2457-non-ascii-idents</a></li><li><a href="2471-lint-test-inner-function.html">2471-lint-test-inner-function</a></li><li><a href="2476-clippy-uno.html">2476-clippy-uno</a></li><li><a href="2480-liballoc.html">2480-liballoc</a></li><li><a href="2495-min-rust-version.html">2495-min-rust-version</a></li><li><a href="2497-if-let-chains.html">2497-if-let-chains</a></li><li><a href="2500-needle.html">2500-needle</a></li><li><a href="2504-fix-error.html">2504-fix-error</a></li><li><a href="2514-union-initialization-and-drop.html">2514-union-initialization-and-drop</a></li><li><a href="2515-type_alias_impl_trait.html">2515-type_alias_impl_trait</a></li><li><a href="2521-c_void-reunification.html">2521-c_void-reunification</a></li><li><a href="2523-cfg-path-version.html">2523-cfg-path-version</a></li><li><a href="2526-const-wildcard.html">2526-const-wildcard</a></li><li><a href="2532-associated-type-defaults.html">2532-associated-type-defaults</a></li><li><a href="2535-or-patterns.html">2535-or-patterns</a></li><li><a href="2539-cfg_attr-multiple-attrs.html">2539-cfg_attr-multiple-attrs</a></li><li><a href="2561-future-possibilities.html">2561-future-possibilities</a></li><li><a href="2565-formal-function-parameter-attributes.html">2565-formal-function-parameter-attributes</a></li><li><a href="2570-linked-list-cursors.html">2570-linked-list-cursors</a></li><li><a href="2574-simd-ffi.html">2574-simd-ffi</a></li><li><a href="2582-raw-reference-mir-operator.html">2582-raw-reference-mir-operator</a></li><li><a href="2591-exhaustive-integer-pattern-matching.html">2591-exhaustive-integer-pattern-matching</a></li><li><a href="2592-futures.html">2592-futures</a></li><li><a href="2603-symbol-name-mangling-v2.html">2603-symbol-name-mangling-v2</a></li><li><a href="2627-raw-dylib-kind.html">2627-raw-dylib-kind</a></li><li><a href="2645-transparent-unions.html">2645-transparent-unions</a></li><li><a href="2657-roadmap-2019.html">2657-roadmap-2019</a></li><li><a href="2678-named-custom-cargo-profiles.html">2678-named-custom-cargo-profiles</a></li><li><a href="2689-compiler-team-contributors.html">2689-compiler-team-contributors</a></li><li><a href="2696-debug-map-key-value.html">2696-debug-map-key-value</a></li><li><a href="2700-associated-constants-on-ints.html">2700-associated-constants-on-ints</a></li><li><a href="2707-dotdot-patterns.html">2707-dotdot-patterns</a></li><li><a href="2795-format-args-implicit-identifiers.html">2795-format-args-implicit-identifiers</a></li><li><a href="2797-project-ffi-unwind.html">2797-project-ffi-unwind</a></li><li><a href="2835-project-safe-transmute.html">2835-project-safe-transmute</a></li><li><a href="2837-demote-apple-32bit.html">2837-demote-apple-32bit</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust RFC Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li>Feature Name: incremental-compilation</li>
<li>Start Date: 2015-08-04</li>
<li>RFC PR: (leave this empty)</li>
<li>Rust Issue: (leave this empty)</li>
</ul>
<a class="header" href="#summary" id="summary"><h1>Summary</h1></a>
<p>Enable the compiler to cache incremental workproducts.</p>
<a class="header" href="#motivation" id="motivation"><h1>Motivation</h1></a>
<p>The goal of incremental compilation is, naturally, to improve build
times when making small edits. Any reader who has never felt the need
for such a feature is strongly encouraged to attempt hacking on the
compiler or servo sometime (naturally, all readers are so encouraged,
regardless of their opinion on the need for incremental compilation).</p>
<a class="header" href="#basic-usage" id="basic-usage"><h2>Basic usage</h2></a>
<p>The basic usage will be that one enables incremental compilation using
a compiler flag like <code>-C incremental-compilation=TMPDIR</code>. The <code>TMPDIR</code>
directory is intended to be an empty directory that the compiler can
use to store intermediate by-products; the compiler will automatically
&quot;GC&quot; this directory, deleting older files that are no longer relevant
and creating new ones.</p>
<a class="header" href="#high-level-design" id="high-level-design"><h2>High-level design</h2></a>
<p>The high-level idea is that we will track the following intermediate
workproducts for every function (and, indeed, for other kinds of items
as well, but functions are easiest to describe):</p>
<ul>
<li>External signature
<ul>
<li>For a function, this would include the types of its arguments,
where-clauses declared on the function, and so forth.</li>
</ul>
</li>
<li>MIR
<ul>
<li>The MIR represents the type-checked statements in the body, in
simplified forms. It is described by <a href="https://github.com/rust-lang/rfcs/pull/1211">RFC #1211</a>. As the MIR
is not fully implemented, this is a non-trivial dependency. We
could instead use the existing annotated HIR, however that would
require a larger effort in terms of porting and adapting data
structures to an incremental setting.  Using the MIR simplifies
things in this respect.</li>
</ul>
</li>
<li>Object files
<ul>
<li>This represents the final result of running LLVM. It may be that
the best strategy is to &quot;cache&quot; compiled code in the form of an
rlib that is progressively patched, or it may be easier to store
individual <code>.o</code> files that must be relinked (anyone who has worked
in a substantial C++ project can attest, however, that linking can
take a non-trivial amount of time).</li>
</ul>
</li>
</ul>
<p>Of course, the key to any incremental design is to determine what must
be changed. This can be encoded in a <em>dependency graph</em>. This graph
connects the various bits of the HIR to the external products
(signatures, MIR, and object files). It is of the utmost importance
that this dependency graph is complete: if edges are missing, the
result will be obscure errors where changes are not fully propagated,
yielding inexplicable behavior at runtime. This RFC proposes an
automatic scheme based on encapsulation.</p>
<a class="header" href="#interaction-with-lints-and-compiler-plugins" id="interaction-with-lints-and-compiler-plugins"><h3>Interaction with lints and compiler plugins</h3></a>
<p>Although rustc does not yet support compiler plugins through a stable
interface, we have long planned to allow for custom lints, syntax
extensions, and other sorts of plugins. It would be nice therefore to
be able to accommodate such plugins in the design, so that their
inputs can be tracked and accounted for as well.</p>
<a class="header" href="#interaction-with-optimization" id="interaction-with-optimization"><h2>Interaction with optimization</h2></a>
<p>It is important to clarify, though, that this design does not attempt
to enable full optimizing for incremental compilation; indeed the two
are somewhat at odds with one another, as full optimization may
perform inlining and inter-function analysis, which can cause small
edits in one function to affect the generated code of another. This
situation is further exacerbated by the fact that LLVM does not
provide any way to track these sorts of dependencies (e.g., one cannot
even determine what inlining took place, though @dotdash suggested a
clever trick of using llvm lifetime hints). Strategies for handling
this are discussed in the <a href="#optimization">Optimization section</a> below.</p>
<a class="header" href="#detailed-design" id="detailed-design"><h1>Detailed design</h1></a>
<p>We begin with a high-level execution plan, followed by sections that
explore aspects of the plan in more detail. The high-level summary
includes links to each of the other sections.</p>
<a class="header" href="#high-level-execution-plan" id="high-level-execution-plan"><h2>High-level execution plan</h2></a>
<p>Regardless of whether it is invoked in incremental compilation mode or
not, the compiler will always parse and macro expand the entire crate,
resulting in a HIR tree. Once we have a complete HIR tree, and if we
are invoked in incremental compilation mode, the compiler will then
try to determine which parts of the crate have changed since the last
execution. For each item, we compute a <a href="#defid">(mostly) stable id</a>
based primarily on the item's name and containing module. We then
compute a hash of its contents and compare that hash against the hash
that the item had in the compilation (if any).</p>
<p>Once we know which items have changed, we consult a
<a href="#depgraph">dependency graph</a> to tell us which artifacts are still
usable. These artifacts can take the form of serializing MIR graphs,
LLVM IR, compiled object code, and so forth. The dependency graph
tells us which bits of AST contributed to each artifact. It is
constructed by dynamically monitoring what the compiler accesses
during execution.</p>
<p>Finally, we can begin execution. The compiler is currently structured
in a series of passes, each of which walks the entire AST. We do not
need to change this structure to enable incremental
compilation. Instead, we continue to do every pass as normal, but when
we come to an item for which we have a pre-existing artifact (for
example, if we are type-checking a fn that has not changed since the
last execution), we can simply skip over that fn instead. Similar
strategies can be used to enable lazy or parallel compilation at later
times. (Eventually, though, it might be nice to restructure the
compiler so that it operates in more of a demand driven style, rather
than a series of sweeping passes.)</p>
<p>When we come to the final LLVM stages, we must
<a href="#optimization">separate the functions into distinct &quot;codegen units&quot;</a>
for the purpose of LLVM code generation. This will build on the
existing &quot;codegen-units&quot; used for parallel code generation. LLVM may
perform inlining or interprocedural analysis within a unit, but not
across units, which limits the amount of reoptimization needed when
one of those functions changes.</p>
<p>Finally, the RFC closes with a discussion of
<a href="#testing">testing strategies</a> we can use to help avoid bugs due to
incremental compilation.</p>
<a class="header" href="#staging" id="staging"><h3>Staging</h3></a>
<p>One important question is how to stage the incremental compilation
work. That is, it'd be nice to start seeing some benefit as soon as
possible. One possible plan is as follows:</p>
<ol>
<li>Implement stable def-ids (in progress, nearly complete).</li>
<li>Implement the dependency graph and tracking system (started).</li>
<li>Experiment with distinct modularization schemes to find the one which
gives the best fragmentation with minimal performance impact.
Or, at least, implement something finer-grained than today's codegen-units.</li>
<li>Persist compiled object code only.</li>
<li>Persist intermediate MIR and generated LLVM as well.</li>
</ol>
<p>The most notable staging point here is that we can begin by just
saving object code, and then gradually add more artifacts that get
saved. The effect of saving fewer things (such as only saving object
code) will simply be to make incremental compilation somewhat less
effective, since we will be forced to re-type-check and re-trans
functions where we might have gotten away with only generating new
object code. However, this is expected to be be a second order effect
overall, particularly since LLVM optimization time can be a very large
portion of compilation.</p>
<p><a id="defid"></a></p>
<a class="header" href="#handling-defids" id="handling-defids"><h2>Handling DefIds</h2></a>
<p>In order to correlate artifacts between compilations, we need some
stable way to name items across compilations (and across crates).  The
compiler currently uses something called a <code>DefId</code> to identify each
item. However, these ids today are based on a node-id, which is just
an index into the HIR and hence will change whenever <em>anything</em>
preceding it in the HIR changes. We need to make the <code>DefId</code> for an
item independent of changes to other items.</p>
<p>Conceptually, the idea is to change <code>DefId</code> into the pair of a crate
and a path:</p>
<pre><code>DEF_ID = (CRATE, PATH)
CRATE = &lt;crate identifier&gt;
PATH = PATH_ELEM | PATH :: PATH_ELEM
PATH_ELEM = (PATH_ELEM_DATA, &lt;disambiguating integer&gt;)
PATH_ELEM_DATA = Crate(ID)
               | Mod(ID)
               | Item(ID)
               | TypeParameter(ID)
               | LifetimeParameter(ID)
               | Member(ID)
               | Impl
               | ...
</code></pre>
<p>However, rather than actually store the path in the compiler, we will
instead intern the paths in the <code>CStore</code>, and the <code>DefId</code> will simply
store an integer. So effectively the <code>node</code> field of <code>DefId</code>, which
currently indexes into the HIR of the appropriate crate, becomes an
index into the crate's list of paths.</p>
<p>For the most part, these paths match up with user's intuitions. So a
struct <code>Foo</code> declared in a module <code>bar</code> would just have a path like
<code>bar::Foo</code>. However, the paths are also able to express things for
which there is no syntax, such as an item declared within a function
body.</p>
<a class="header" href="#disambiguation" id="disambiguation"><h3>Disambiguation</h3></a>
<p>For the most part, paths should naturally be unique. However, there
are some cases where a single parent may have multiple children with
the same path. One case would be erroneous programs, where there are
(e.g.) two structs declared with the same name in the same
module. Another is that some items, such as impls, do not have a name,
and hence we cannot easily distinguish them. Finally, it is possible
to declare multiple functions with the same name within function bodies:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    {
        fn bar() { }
    }

    {
        fn bar() { }
    }
}
#}</code></pre></pre>
<p>All of these cases are handled by a simple <em>disambiguation</em> mechanism.
The idea is that we will assign a path to each item as we traverse the
HIR. If we find that a single parent has two children with the same
name, such as two impls, then we simply assign them unique integers in
the order that they appear in the program text. For example, the
following program would use the paths shown (I've elided the
disambiguating integer except where it is relevant):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {               // Path: &lt;root&gt;::foo
    pub struct Type { } // Path: &lt;root&gt;::foo::Type
    impl Type {         // Path: &lt;root&gt;::foo::(&lt;impl&gt;,0)
        fn bar() {..}   // Path: &lt;root&gt;::foo::(&lt;impl&gt;,0)::bar
    }
    impl Type { }       // Path: &lt;root&gt;::foo::(&lt;impl&gt;,1)
}
#}</code></pre></pre>
<p>Note that the impls were arbitrarily assigned indices based on the order
in which they appear. This does mean that reordering impls may cause
spurious recompilations. We can try to mitigate this somewhat by making the
path entry for an impl include some sort of hash for its header or its contents,
but that will be something we can add later.</p>
<p><em>Implementation note:</em> Refactoring DefIds in this way is a large
task. I've made several attempts at doing it, but my latest branch
appears to be working out (it is not yet complete). As a side benefit,
I've uncovered a few fishy cases where we using the node id from
external crates to index into the local crate's HIR map, which is
certainly incorrect. --nmatsakis</p>
<p><a id="depgraph"></p>
<a class="header" href="#identifying-and-tracking-dependencies" id="identifying-and-tracking-dependencies"><h2>Identifying and tracking dependencies</h2></a>
<a class="header" href="#core-idea-a-fine-grained-dependency-graph" id="core-idea-a-fine-grained-dependency-graph"><h3>Core idea: a fine-grained dependency graph</h3></a>
<p>Naturally any form of incremental compilation requires a detailed
understanding of how each work item is dependent on other work items.
This is most readily visualized as a dependency graph; the
finer-grained the nodes and edges in this graph, the better. For example,
consider a function <code>foo</code> that calls a function <code>bar</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    ...
    bar();
    ...
}
#}</code></pre></pre>
<p>Now imagine that the body (but not the external signature) of <code>bar</code>
changes. Do we need to type-check <code>foo</code> again? Of course not: <code>foo</code>
only cares about the signature of <code>bar</code>, not its body. For the
compiler to understand this, though, we'll need to create distinct
graph nodes for the signature and body of each function.</p>
<p>(Note that our policy of making &quot;external signatures&quot; fully explicit
is helpful here. If we supported, e.g., return type inference, than it
would be harder to know whether a change to <code>bar</code> means <code>foo</code> must be
recompiled.)</p>
<a class="header" href="#categories-of-nodes" id="categories-of-nodes"><h3>Categories of nodes</h3></a>
<p>This section gives a kind of &quot;first draft&quot; of the set of graph
nodes/edges that we will use. It is expected that the full set of
nodes/edges will evolve in the course of implementation (and of course
over time as well).  In particular, some parts of the graph as
presented here are intentionally quite coarse and we envision that the
graph will be gradually more fine-grained.</p>
<p>The nodes fall into the following categories:</p>
<ul>
<li><strong>HIR nodes.</strong> Represent some portion of the input HIR. For example,
the body of a fn as a HIR node. These are the inputs to the entire
compilation process.
<ul>
<li>Examples:
<ul>
<li><code>SIG(X)</code> would represent the signature of some fn item
<code>X</code> that the user wrote (i.e., the names of the types,
where-clauses, etc)</li>
<li><code>BODY(X)</code> would be the body of some fn item <code>X</code></li>
<li>and so forth</li>
</ul>
</li>
</ul>
</li>
<li><strong>Metadata nodes.</strong> These represent portions of the metadata from
another crate. Each piece of metadata will include a hash of its
contents. When we need information about an external item, we load
that info out of the metadata and add it into the IR nodes below;
this can be represented in the graph using edges. This means that
incremental compilation can also work across crates.</li>
<li><strong>IR nodes.</strong> Represent some portion of the computed IR. For
example, the MIR representation of a fn body, or the <code>ty</code>
representation of a fn signature. These also frequently correspond
to a single entry in one of the various compiler hashmaps. These are
the outputs (and intermediate steps) of the compilation process
<ul>
<li>Examples:
<ul>
<li><code>ITEM_TYPE(X)</code> -- entry in the obscurely named <code>tcache</code> table
for <code>X</code> (what is returned by the rather-more-clearly-named
<code>lookup_item_type</code>)</li>
<li><code>PREDICATES(X)</code> -- entry in the <code>predicates</code> table</li>
<li><code>ADT(X)</code> -- ADT node for a struct (this may want to be more
fine-grained, particularly to cover the ivars)</li>
<li><code>MIR(X)</code> -- the MIR for the item <code>X</code></li>
<li><code>LLVM(X)</code> -- the LLVM IR for the item <code>X</code></li>
<li><code>OBJECT(X)</code> -- the object code generated by compiling some item
<code>X</code>; the precise way that this is saved will depend on whether
we use <code>.o</code> files that are linked together, or if we attempt to
amend the shared library in place.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Procedure nodes.</strong> These represent various passes performed by the
compiler. For example, the act of type checking a fn body, or the
act of constructing MIR for a fn body. These are the &quot;glue&quot; nodes
that wind up reading the inputs and creating the outputs, and hence
which ultimately tie the graph together.
<ul>
<li>Examples:
<ul>
<li><code>COLLECT(X)</code> -- the collect code executing on item <code>X</code></li>
<li><code>WFCHECK(X)</code> -- the wfcheck code executing on item <code>X</code></li>
<li><code>BORROWCK(X)</code> -- the borrowck code executing on item <code>X</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>To see how this all fits together, let's consider the graph for a
simple example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    bar();
}

fn bar() {
}
#}</code></pre></pre>
<p>This might generate a graph like the following (the following sections
will describe how this graph is constructed). Note that this is not a
complete graph, it only shows the data needed to produce <code>MIR(foo)</code>.</p>
<pre><code>BODY(foo) ----------------------------&gt; TYPECK(foo) --&gt; MIR(foo)
                                          ^ ^ ^ ^         |
SIG(foo) ----&gt; COLLECT(foo)               | | | |         |
                 |                        | | | |         v
                 +--&gt; ITEM_TYPE(foo) -----+ | | |      LLVM(foo)
                 +--&gt; PREDICATES(foo) ------+ | |         |
                                              | |         |
SIG(bar) ----&gt; COLLECT(bar)                   | |         v
                 |                            | |     OBJECT(foo)
                 +--&gt; ITEM_TYPE(bar) ---------+ |
                 +--&gt; PREDICATES(bar) ----------+
</code></pre>
<p>As you can see, this graph indicates that if the signature of either
function changes, we will need to rebuild the MIR for <code>foo</code>. But there
is no path from the body of <code>bar</code> to the MIR for foo, so changes there
need not trigger a rebuild (we are assuming here that <code>bar</code> is not
inlined into <code>foo</code>; see the <a href="#optimization">section on optimizations</a>
for more details on how to handle those sorts of dependencies).</p>
<a class="header" href="#building-the-graph" id="building-the-graph"><h3>Building the graph</h3></a>
<p>It is very important the dependency graph contain <em>all</em> edges. If any
edges are missing, it will mean that we will get inconsistent builds,
where something should have been rebuilt what was not. Hand-coding a
graph like this, therefore, is probably not the best choice -- we
might get it right at first, but it's easy to for such a setup to fall
out of sync as the code is edited. (For example, if a new table is
added, or a function starts reading data that it didn't before.)</p>
<p>Another consideration is compiler plugins. At present, of course, we
don't have a stable API for such plugins, but eventually we'd like to
support a rich family of them, and they may want to participate in the
incremental compilation system as well. So we need to have an idea of
what data a plugin accesses and modifies, and for what purpose.</p>
<p>The basic strategy then is to build the graph dynamically with an API
that looks something like this:</p>
<ul>
<li><code>push_procedure(procedure_node)</code></li>
<li><code>pop_procedure(procedure_node)</code></li>
<li><code>read_from(data_node)</code></li>
<li><code>write_to(data_node)</code></li>
</ul>
<p>Here, the <code>procedure_node</code> arguments are one of the procedure labels
above (like <code>COLLECT(X)</code>), and the <code>data_node</code> arguments are either
HIR or IR nodes (e.g., <code>SIG(X)</code>, <code>MIR(X)</code>).</p>
<p>The idea is that we maintain for each thread a stack of active
procedures. When <code>push_procedure</code> is called, a new entry is pushed
onto that stack, and when <code>pop_procedure</code> is called, an entry is
popped. When <code>read_from(D)</code> is called, we add an edge from <code>D</code> to the
top of the stack (it is an error if the stack is empty). Similarly,
<code>write_to(D)</code> adds an edge from the top of the stack to <code>D</code>.</p>
<p>Naturally it is easy to misuse the above methods: one might forget to
push/pop a procedure at the right time, or fail to invoke
read/write. There are a number of refactorings we can do on the
compiler to make this scheme more robust.</p>
<a class="header" href="#procedures" id="procedures"><h4>Procedures</h4></a>
<p>Most of the compiler passes operate an item at a time. Nonetheless,
they are largely encoded using the standard visitor, which walks all
HIR nodes. We can refactor most of them to instead use an outer
visitor, which walks items, and an inner visitor, which walks a
particular item. (Many passes, such as borrowck, already work this
way.) This outer visitor will be parameterized with the label for the
pass, and will automatically push/pop procedure nodes as appropriate.
This means that as long as you base your pass on the generic
framework, you don't really have to worry.</p>
<p>In general, while I described the general case of a stack of procedure
nodes, it may be desirable to try and maintain the invariant that
there is only ever one procedure node on the stack at a
time. Otherwise, failing to push/pop a procedure at the right time
could result in edges being added to the wrong procedure. It is likely
possible to refactor things to maintain this invariant, but that has
to be determined as we go.</p>
<a class="header" href="#ir-nodes" id="ir-nodes"><h4>IR nodes</h4></a>
<p>Adding edges to the IR nodes that represent the compiler's
intermediate byproducts can be done by leveraging privacy. The idea is
to enforce the use of accessors to the maps and so forth, rather than
allowing direct access. These accessors will call the <code>read_from</code> and
<code>write_to</code> methods as appropriate to add edges to/from the current
active procedure.</p>
<a class="header" href="#hir-nodes" id="hir-nodes"><h4>HIR nodes</h4></a>
<p>HIR nodes are a bit trickier to encapsulate. After all, the HIR map
itself gives access to the root of the tree, which in turn gives
access to everything else -- and encapsulation is harder to enforce
here.</p>
<p>Some experimentation will be required here, but the rough plan is to:</p>
<ol>
<li>Leveraging the HIR, move away from storing the HIR as one large tree,
and instead have a tree of items, with each item containing only its own
content.
<ul>
<li>This way, giving access to the HIR node for an item doesn't implicitly
give access to all of its subitems.</li>
<li>Ideally this would match precisely the HIR nodes we setup, which
means that e.g. a function would have a subtree corresponding to
its signature, and a separating subtree corresponding to its
body.</li>
<li>We can still register the lexical nesting of items by linking &quot;indirectly&quot;
via a <code>DefId</code>.</li>
</ul>
</li>
<li>Annotate the HIR map accessor methods so that they add appropriate
read/write edges.</li>
</ol>
<p>This will integrate with the &quot;default visitor&quot; described under
procedure nodes. This visitor can hand off just an opaque id for each
item, requiring the pass itself to go through the map to fetch the
actual HIR, thus triggering a read edge (we might also bake this
behavior into the visitor for convenience).</p>
<a class="header" href="#persisting-the-graph" id="persisting-the-graph"><h3>Persisting the graph</h3></a>
<p>Once we've built the graph, we have to persist it, along with some
associated information. The idea is that the compiler, when invoked,
will be supplied with a directory. It will store temporary files in
there. We could also consider extending the design to support use by
multiple simultaneous compiler invocations, which could mean
incremental compilation results even across branches, much like ccache
(but this may require tweaks to the GC strategy).</p>
<p>Once we get to the point of persisting the graph, we don't need the
full details of the graph. The process nodes, in particular, can be
removed. They exist only to create links between the other nodes. To
remove them, we first compute the transitive reachability relationship
and then drop the process nodes out of the graph, leaving only the HIR
nodes (inputs) and IR nodes (output).  (In fact, we only care about
the IR nodes that we intend to persist, which may be only a subset of
the IR nodes, so we can drop those that we do not plan to persist.)</p>
<p>For each HIR node, we will hash the HIR and store that alongside the
node. This indicates precisely the state of the node at the time.
Note that we only need to hash the HIR itself; contextual information
(like <code>use</code> statements) that are needed to interpret the text will be
part of a separate HIR node, and there should be edges from that node
to the relevant compiler data structures (such as the name resolution
tables).</p>
<p>For each IR node, we will serialize the relevant information from the
table and store it. The following data will need to be serialized:</p>
<ul>
<li>Types, regions, and predicates</li>
<li>ADT definitions</li>
<li>MIR definitions</li>
<li>Identifiers</li>
<li>Spans</li>
</ul>
<p>This list was gathered primarily by spelunking through the compiler.
It is probably somewhat incomplete. The appendix below lists an
exhaustive exploration.</p>
<a class="header" href="#reusing-and-garbage-collecting-artifacts" id="reusing-and-garbage-collecting-artifacts"><h3>Reusing and garbage collecting artifacts</h3></a>
<p>The general procedure when the compiler starts up in incremental mode
will be to parse and macro expand the input, create the corresponding
set of HIR nodes, and compute their hashes. We can then load the
previous dependency graph and reconcile it against the current state:</p>
<ul>
<li>If the dep graph contains a HIR node that is no longer present in the
source, that node is queued for deletion.</li>
<li>If the same HIR node exists in both the dep graph and the input, but
the hash has changed, that node is queued for deletion.</li>
<li>If there is a HIR node that exists only in the input, it is added
to the dep graph with no dependencies.</li>
</ul>
<p>We then delete the transitive closure of nodes queued for deletion
(that is, all the HIR nodes that have changed or been removed, and all
nodes reachable from those HIR nodes). As part of the deletion
process, we remove whatever on disk artifact that may have existed.</p>
<p><a id="span"></a></p>
<a class="header" href="#handling-spans" id="handling-spans"><h3>Handling spans</h3></a>
<p>There are times when the precise span of an item is a significant part
of its metadata. For example, debuginfo needs to identify line numbers
and so forth. However, editing one fn will affect the line numbers for
all subsequent fns in the same file, and it'd be best if we can avoid
recompiling all of them. Our plan is to phase span support in incrementally:</p>
<ol>
<li>Initially, the AST hash will include the filename/line/column,
which does mean that later fns in the same file will have to be
recompiled (somewhat unnnecessarily).</li>
<li>Eventually, it would be better to encode spans by identifying a
particular AST node (relative to the root of the item). Since we
are hashing the structure of the AST, we know the AST from the
previous and current compilation will match, and thus we can
compute the current span by finding tha corresponding AST node and
loading its span. This will require some refactoring and work however.</li>
</ol>
<p><a id="optimization"></a></p>
<a class="header" href="#optimization-and-codegen-units" id="optimization-and-codegen-units"><h2>Optimization and codegen units</h2></a>
<p>There is an inherent tension between incremental compilation and full
optimization. Full optimization may perform inlining and
inter-function analysis, which can cause small edits in one function
to affect the generated code of another. This situation is further
exacerbated by the fact that LLVM does not provide any means to track
when one function was inlined into another, or when some sort of
interprocedural analysis took place (to the best of our knowledge, at
least).</p>
<p>This RFC proposes a simple mechanism for permitting aggressive
optimization, such as inlining, while also supporting reasonable
incremental compilation. The idea is to create <em>codegen units</em> that
compartmentalize closely related functions (for example, on a module
boundary). This means that those compartmentalized functions may
analyze one another, while treating functions from other compartments
as opaque entities. This means that when a function in compartment X
changes, we know that functions from other compartments are unaffected
and their object code can be reused. Moreover, while the other
functions in compartment X must be re-optimized, we can still reuse
the existing LLVM IR. (These are the same codegen units as we use for
parallel codegen, but setup differently.)</p>
<p>In terms of the dependency graph, we would create one IR node
representing the codegen unit. This would have the object code as an
associated artifact. We would also have edges from each component of
the codegen unit. As today, generic or inlined functions would not
belong to any codegen unit, but rather would be instantiated anew into
each codegen unit in which they are (transitively) referenced.</p>
<p>There is an analogy here with C++, which naturally faces the same
problems. In that setting, templates and inlineable functions are
often placed into header files. Editing those header files naturally
triggers more recompilation. The compiler could employ a similar
strategy by replicating things that look like good candidates for
inlining into each module; call graphs and profiling information may
be a good input for such heuristics.</p>
<p><a id="testing"></a></p>
<a class="header" href="#testing-strategy" id="testing-strategy"><h2>Testing strategy</h2></a>
<p>If we are not careful, incremental compilation has the potential to
produce an infinite stream of irreproducible bug reports, so it's
worth considering how we can best test this code.</p>
<a class="header" href="#regression-tests" id="regression-tests"><h3>Regression tests</h3></a>
<p>The first and most obvious piece of infrastructure is something for
reliable regression testing. The plan is simply to have a series of
sources and patches. The source will have each patch applied in
sequence, rebuilding (incrementally) at each point. We can then check
that (a) we only rebuilt what we expected to rebuild and (b) compare
the result with the result of a fresh build from scratch.  This allows
us to build up tests for specific scenarios or bug reports, but
doesn't help with <em>finding</em> bugs in the first place.</p>
<a class="header" href="#replaying-cratesio-versions-and-git-history" id="replaying-cratesio-versions-and-git-history"><h3>Replaying crates.io versions and git history</h3></a>
<p>The next step is to search across crates.io for consecutive
releases. For a given package, we can checkout version <code>X.Y</code> and then
version <code>X.(Y+1)</code> and check that incrementally building from one to
the other is successful and that all tests still yield the same
results as before (pass or fail).</p>
<p>A similar search can be performed across git history, where we
identify pairs of consecutive commits. This has the advantage of being
more fine-grained, but the disadvantage of being a MUCH larger search
space.</p>
<a class="header" href="#fuzzing" id="fuzzing"><h3>Fuzzing</h3></a>
<p>The problem with replaying crates.io versions and even git commits is
that they are probably much larger changes than the typical
recompile. Another option is to use fuzzing, making &quot;innocuous&quot;
changes that should trigger a recompile. Fuzzing is made easier here
because we have an oracle -- that is, we can check that the results of
recompiling incrementally match the results of compiling from scratch.
It's also not necessary that the edits are valid Rust code, though we
should test that too -- in particular, we want to test that the proper
errors are reported when code is invalid, as well.  @nrc also
suggested a clever hybrid, where we use git commits as a source for
the fuzzer's edits, gradually building up the commit.</p>
<a class="header" href="#drawbacks" id="drawbacks"><h1>Drawbacks</h1></a>
<p>The primary drawback is that incremental compilation may introduce a
new vector for bugs. The design mitigates this concern by attempting
to make the construction of the dependency graph as automated as
possible. We also describe automated testing strategies.</p>
<a class="header" href="#alternatives" id="alternatives"><h1>Alternatives</h1></a>
<p>This design is an evolution from <a href="https://github.com/rust-lang/rfcs/pull/594">RFC 594</a>.</p>
<a class="header" href="#unresolved-questions" id="unresolved-questions"><h1>Unresolved questions</h1></a>
<p>None.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="1291-promote-libc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="1300-intrinsic-semantics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="1291-promote-libc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="1300-intrinsic-semantics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
